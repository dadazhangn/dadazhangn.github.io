<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Rust 学习笔记（一）</title>
    <url>/2024/06/04/Rust_stu_one/</url>
    <content><![CDATA[<h1 id="Rust-学习笔记（一）"><a href="#Rust-学习笔记（一）" class="headerlink" title="Rust 学习笔记（一）"></a>Rust 学习笔记（一）</h1><h2 id="变量绑定与解构"><a href="#变量绑定与解构" class="headerlink" title="变量绑定与解构"></a><a href="https://course.rs/basic/variable.html#变量绑定与解构">变量绑定与解构</a></h2><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a><a href="https://course.rs/basic/variable.html#变量命名">变量命名</a></h2><p>在命名方面，和其它语言没有区别，不过当给变量命名时，需要遵循 <a href="https://course.rs/practice/naming.html">Rust 命名规范</a>。</p>
<blockquote>
<p>Rust 语言有一些<strong>关键字</strong>（<em>keywords</em>），和其他语言一样，这些关键字都是被保留给 Rust 语言使用的，因此，它们不能被用作变量或函数的名称。</p>
</blockquote>
<h2 id="变量绑定"><a href="#变量绑定" class="headerlink" title="变量绑定"></a><a href="https://course.rs/basic/variable.html#变量绑定">变量绑定</a></h2><p>在其它语言中，我们用 <code>var a = &quot;hello world&quot;</code> 的方式给 <code>a</code> 赋值，也就是把等式右边的 <code>&quot;hello world&quot;</code> 字符串赋值给变量 <code>a</code> ，而在 Rust 中，我们这样写： <code>let a = &quot;hello world&quot;</code> ，同时给这个过程起了另一个名字：<strong>变量绑定</strong>。</p>
<h2 id="变量可变性"><a href="#变量可变性" class="headerlink" title="变量可变性"></a><a href="https://course.rs/basic/variable.html#变量可变性">变量可变性</a></h2><p>Rust 的变量在默认情况下是<strong>不可变的</strong>。可以通过 <code>mut</code> 关键字让变量变为<strong>可变的</strong>，让设计更灵活。</p>
<p>如果变量 <code>a</code> 不可变，那么一旦为它绑定值，就不能再修改 <code>a</code>。在工程目录下使用 <code>cargo new variables</code> 新建一个项目，叫做 <em>variables</em> 。</p>
<p>然后在新建的 <em>variables</em> 目录下，编辑 <em>src/main.rs</em> ，改为下面代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存文件，再使用 <code>cargo run</code> 运行它，迎面而来的是一条错误提示：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">error[E0384]: cannot assign twice to immutable variable `x`</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:4:5</span></span><br><span class="line">  |</span><br><span class="line">2 |     let x = 5;</span><br><span class="line">  |         -</span><br><span class="line">  |         |</span><br><span class="line">  |         first assignment to `x`</span><br><span class="line">  |         help: consider making this binding mutable: `mut x`</span><br><span class="line">3 |     println!(&quot;The value of x is: &#123;&#125;&quot;, x);</span><br><span class="line">4 |     x = 6;</span><br><span class="line">  |     ^^^^^ cannot assign twice to immutable variable</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br></pre></td></tr></table></figure>
<p>具体的错误原因是 <code>cannot assign twice to immutable variable x</code>（无法对不可变的变量进行重复赋值），因为我们想为不可变的 <code>x</code> 变量再次赋值。</p>
<p>在 Rust 中，可变性很简单，只要在变量名前加一个 <code>mut</code> 即可, 而且这种显式的声明方式还会给后来人传达这样的信息：嗯，这个变量在后面代码部分会发生改变。</p>
<p>为了让变量声明为可变,将 <em>src/main.rs</em> 改为以下内容：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序将得到下面结果：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.30s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value of x is: 5</span><br><span class="line">The value of x is: 6</span><br></pre></td></tr></table></figure>
<p>选择可变还是不可变，更多的还是取决于你的使用场景，例如不可变可以带来安全性，但是丧失了灵活性和性能（如果你要改变，就要重新创建一个新的变量，这里涉及到内存对象的再分配）。而可变变量最大的好处就是使用上的灵活性和性能上的提升。</p>
<h2 id="使用下划线开头忽略未使用的变量"><a href="#使用下划线开头忽略未使用的变量" class="headerlink" title="使用下划线开头忽略未使用的变量"></a><a href="https://course.rs/basic/variable.html#使用下划线开头忽略未使用的变量">使用下划线开头忽略未使用的变量</a></h2><p>如果你创建了一个变量却不在任何地方使用它，Rust 通常会给你一个警告，因为这可能会是个 BUG。但是有时创建一个不会被使用的变量是有用的，比如你正在设计原型或刚刚开始一个项目。这时<strong>你希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头</strong>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>cargo run</code> 运行下试试:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">warning: unused variable: `y`</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:3:9</span></span><br><span class="line">  |</span><br><span class="line">3 |     let y = 10;</span><br><span class="line">  |         ^ help: 如果 y 故意不被使用，请添加一个下划线前缀: `_y`</span><br><span class="line">  |</span><br><span class="line">  = note: `#[warn(unused_variables)]` on by default</span><br></pre></td></tr></table></figure>
<p>可以看到，两个变量都是只有声明，没有使用，但是编译器却独独给出了 <code>y</code> 未被使用的警告，充分说明了 <code>_</code> 变量名前缀在这里发挥的作用。</p>
<p>值得注意的是，这里编译器还很善意的给出了提示( Rust 的编译器非常强大，这里的提示只是小意思 ): 将 <code>y</code> 修改 <code>_y</code> 即可。这里就不再给出代码，留给大家手动尝试并观察下运行结果。</p>
<p>更多关于 <code>_x</code> 的使用信息，请阅读后面的<a href="https://course.rs/basic/match-pattern/all-patterns.html?highlight=_#使用下划线开头忽略未使用的变量">模式匹配章节</a>。</p>
<h2 id="变量解构"><a href="#变量解构" class="headerlink" title="变量解构"></a><a href="https://course.rs/basic/variable.html#变量解构">变量解构</a></h2><p><code>let</code> 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (a, <span class="keyword">mut</span> b): (<span class="type">bool</span>,<span class="type">bool</span>) = (<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// a = true,不可变; b = false，可变</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;, b = &#123;:?&#125;&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    b = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解构式赋值"><a href="#解构式赋值" class="headerlink" title="解构式赋值"></a><a href="https://course.rs/basic/variable.html#解构式赋值">解构式赋值</a></h3><p>在 <a href="https://course.rs/appendix/rust-versions/1.59.html">Rust 1.59</a> 版本后，我们可以在赋值语句的左式中使用元组、切片和结构体模式了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Struct</span> &#123;</span><br><span class="line">    e: <span class="type">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (a, b, c, d, e);</span><br><span class="line"></span><br><span class="line">    (a, b) = (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// _ 代表匹配一个值，不关心具体的值是什么，因此没有使用一个变量名而是使用了 _</span></span><br><span class="line">    [c, .., d, _] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    Struct &#123; e, .. &#125; = Struct &#123; e: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>], [a, b, c, d, e]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种使用方式跟之前的 <code>let</code> 保持了一致性，但是 <code>let</code> 会重新绑定，而这里仅仅是对之前绑定的变量进行再赋值。</p>
<p>需要注意的是，使用 <code>+=</code> 的赋值语句还不支持解构式赋值。</p>
<blockquote>
<p>这里用到了模式匹配的一些语法，如果大家看不懂没关系，可以在学完模式匹配章节后，再回头来看。</p>
</blockquote>
<h2 id="变量和常量之间的差异"><a href="#变量和常量之间的差异" class="headerlink" title="变量和常量之间的差异"></a><a href="https://course.rs/basic/variable.html#变量和常量之间的差异">变量和常量之间的差异</a></h2><p>变量的值不能更改可能让你想起其他另一个很多语言都有的编程概念：<strong>常量</strong>(<em>constant</em>)。与不可变变量一样，常量也是绑定到一个常量名且不允许更改的值，但是常量和变量之间存在一些差异：</p>
<ul>
<li>常量不允许使用 <code>mut</code>。<strong>常量不仅仅默认不可变，而且自始至终不可变</strong>，因为常量在编译完成后，已经确定它的值。</li>
<li>常量使用 <code>const</code> 关键字而不是 <code>let</code> 关键字来声明，并且值的类型<strong>必须</strong>标注。</li>
</ul>
<p>下面是一个常量声明的例子，其常量名为 <code>MAX_POINTS</code>，值设置为 <code>100,000</code>。（Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词，另外对数字字面量可插入下划线以提高可读性）：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_POINTS: <span class="type">u32</span> = <span class="number">100_000</span>;</span><br></pre></td></tr></table></figure>
<p>常量可以在任意作用域内声明，包括全局作用域，在声明的作用域内，常量在程序运行的整个过程中都有效。对于需要在多处代码共享一个不可变的值时非常有用，例如游戏中允许玩家赚取的最大点数或光速。</p>
<blockquote>
<p>在实际使用中，最好将程序中用到的硬编码值都声明为常量，对于代码后续的维护有莫大的帮助。如果将来需要更改硬编码的值，你也只需要在代码中更改一处即可。</p>
</blockquote>
<h2 id="变量遮蔽-shadowing"><a href="#变量遮蔽-shadowing" class="headerlink" title="变量遮蔽(shadowing)"></a><a href="https://course.rs/basic/variable.html#变量遮蔽shadowing">变量遮蔽(shadowing)</a></h2><p>Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 在main函数的作用域内对之前的x进行遮蔽</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在当前的花括号作用域内，对之前的x进行遮蔽</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序首先将数值 <code>5</code> 绑定到 <code>x</code>，然后通过重复使用 <code>let x =</code> 来遮蔽之前的 <code>x</code>，并取原来的值加上 <code>1</code>，所以 <code>x</code> 的值变成了 <code>6</code>。第三个 <code>let</code> 语句同样遮蔽前面的 <code>x</code>，取之前的值并乘上 <code>2</code>，得到的 <code>x</code> 最终值为 <code>12</code>。当运行此程序，将输出以下内容：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">   ...</span><br><span class="line">The value of x in the inner scope is: 12</span><br><span class="line">The value of x is: 6</span><br></pre></td></tr></table></figure>
<p>这和 <code>mut</code> 变量的使用是不同的，第二个 <code>let</code> 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配 ，而 <code>mut</code> 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。</p>
<p>变量遮蔽的用处在于，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。</p>
<p>例如，假设有一个程序要统计一个空格字符串的空格数量：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line"><span class="comment">// usize数值类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>();</span><br></pre></td></tr></table></figure>
<p>这种结构是允许的，因为第一个 <code>spaces</code> 变量是一个字符串类型，第二个 <code>spaces</code> 变量是一个全新的变量且和第一个具有相同的变量名，且是一个数值类型。所以变量遮蔽可以帮我们节省些脑细胞，不用去想如 <code>spaces_str</code> 和 <code>spaces_num</code> 此类的变量名；相反我们可以重复使用更简单的 <code>spaces</code> 变量名。如果你不用 <code>let</code> :</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line">spaces = spaces.<span class="title function_ invoke__">len</span>();</span><br></pre></td></tr></table></figure>
<p>运行一下，发现编译器报错：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:3:14</span></span><br><span class="line">  |</span><br><span class="line">3 |     spaces = spaces.len();</span><br><span class="line">  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br></pre></td></tr></table></figure>
<p>显然，Rust 对类型的要求很严格，不允许将整数类型 <code>usize</code> 赋值给字符串类型。<code>usize</code> 是一种 CPU 相关的整数类型。</p>
<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a><a href="https://course.rs/basic/base-type/index.html#基本类型">基本类型</a></h1><ul>
<li><p>数值类型: 有符号整数 (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>)、 无符号整数 (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>) 、浮点数 (<code>f32</code>, <code>f64</code>)、以及有理数、复数</p>
</li>
<li><p>字符串：字符串字面量和字符串切片 <code>&amp;str</code></p>
</li>
<li><p>布尔类型： <code>true</code>和<code>false</code></p>
</li>
<li><p>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</p>
</li>
<li><p>单元类型: 即 <code>()</code> ，其唯一的值也是 <code>()</code></p>
<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a><a href="https://course.rs/basic/base-type/numbers.html#整数类型">整数类型</a></h2><p><strong>整数</strong>是没有小数部分的数字。之前使用过的 <code>i32</code> 类型，表示有符号的 32 位整数（ <code>i</code> 是英文单词 <em>integer</em> 的首字母，与之相反的是 <code>u</code>，代表无符号 <code>unsigned</code> 类型）。下表显示了 Rust 中的内置的整数类型：</p>
<p>| 长度       | 有符号类型 | 无符号类型 |<br>| ————— | ————— | ————— |<br>| 8 位       | <code>i8</code>       | <code>u8</code>       |<br>| 16 位      | <code>i16</code>      | <code>u16</code>      |<br>| 32 位      | <code>i32</code>      | <code>u32</code>      |<br>| 64 位      | <code>i64</code>      | <code>u64</code>      |<br>| 128 位     | <code>i128</code>     | <code>u128</code>     |<br>| 视架构而定 | <code>isize</code>    | <code>usize</code>    |</p>
<p><a href="https://course.rs/basic/base-type/numbers.html#整型溢出">整型溢出</a></p>
</li>
</ul>
<p>要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：</p>
<ul>
<li>使用 <code>wrapping_*</code> 方法在所有模式下都按照补码循环溢出规则处理，例如 <code>wrapping_add</code></li>
<li>如果使用 <code>checked_*</code> 方法时发生溢出，则返回 <code>None</code> 值</li>
<li>使用 <code>overflowing_*</code> 方法返回该值和一个指示是否存在溢出的布尔值</li>
<li>使用 <code>saturating_*</code> 方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值，例如:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">100u8</span>.<span class="title function_ invoke__">saturating_add</span>(<span class="number">1</span>), <span class="number">101</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="type">u8</span>::MAX.<span class="title function_ invoke__">saturating_add</span>(<span class="number">127</span>), <span class="type">u8</span>::MAX);</span><br></pre></td></tr></table></figure>
<p>演示<code>wrapping_*</code>方法的示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> : <span class="type">u8</span> = <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a.<span class="title function_ invoke__">wrapping_add</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);  <span class="comment">// 19</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a><a href="https://course.rs/basic/base-type/numbers.html#浮点类型">浮点类型</a></h2><p><strong>浮点类型数字</strong> 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： <code>f32</code> 和 <code>f64</code>，分别为 32 位和 64 位大小。默认浮点类型是 <code>f64</code>，在现代的 CPU 中它的速度与 <code>f32</code> 几乎相同，但精度更高。</p>
<p>下面是一个演示浮点数的示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>; <span class="comment">// f64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浮点数根据 <code>IEEE-754</code> 标准实现。<code>f32</code> 类型是单精度浮点型，<code>f64</code> 为双精度。</p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a><a href="https://course.rs/basic/base-type/numbers.html#nan">NaN</a></h4><p>对于数学上未定义的结果，例如对负数取平方根 <code>-42.1.sqrt()</code> ，会产生一个特殊的结果：Rust 的浮点数类型使用 <code>NaN</code> (not a number)来处理这些情况。</p>
<h2 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a><a href="https://course.rs/basic/base-type/numbers.html#数字运算">数字运算</a></h2><p>Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取模运算。下面代码各使用一条 <code>let</code> 语句来说明相应运算的用法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 加法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = <span class="number">5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">difference</span> = <span class="number">95.5</span> - <span class="number">4.3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乘法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">product</span> = <span class="number">4</span> * <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">quotient</span> = <span class="number">56.7</span> / <span class="number">32.2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求余</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">remainder</span> = <span class="number">43</span> % <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些语句中的每个表达式都使用了数学运算符，并且计算结果为一个值，然后绑定到一个变量上。</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a><a href="https://course.rs/basic/base-type/numbers.html#位运算">位运算</a></h2><p>Rust的位运算基本上和其他语言一样</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp; 位与</td>
<td>相同位置均为1时则为1，否则为0</td>
</tr>
<tr>
<td>\</td>
<td>位或</td>
<td>相同位置只要有1时则为1，否则为0</td>
</tr>
<tr>
<td>^ 异或</td>
<td>相同位置不相同则为1，相同则为0</td>
</tr>
<tr>
<td>! 位非</td>
<td>把位中的0和1相互取反，即0置为1，1置为0</td>
</tr>
<tr>
<td>&lt;&lt; 左移</td>
<td>所有位向左移动指定位数，右位补0</td>
</tr>
<tr>
<td>&gt;&gt; 右移</td>
<td>所有位向右移动指定位数，带符号移动（正数补0，负数补1）</td>
</tr>
</tbody>
</table>
</div>
<h2 id="序列-Range"><a href="#序列-Range" class="headerlink" title="序列(Range)"></a><a href="https://course.rs/basic/base-type/numbers.html#序列range">序列(Range)</a></h2><p>Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 <code>1..5</code>，生成从 1 到 4 的连续数字，不包含 5 ；<code>1..=5</code>，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-As-完成类型转换"><a href="#使用-As-完成类型转换" class="headerlink" title="使用 As 完成类型转换"></a><a href="https://course.rs/basic/base-type/numbers.html#使用-as-完成类型转换">使用 As 完成类型转换</a></h2><p>Rust 中可以使用 As 来完成一个类型到另一个类型的转换，其最常用于将原始类型转换为其他原始类型，但是它也可以完成诸如将指针转换为地址、地址转换为指针以及将指针转换为其他指针等功能。</p>
<h2 id="有理数和复数"><a href="#有理数和复数" class="headerlink" title="有理数和复数"></a><a href="https://course.rs/basic/base-type/numbers.html#有理数和复数">有理数和复数</a></h2><p>Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：</p>
<ul>
<li>有理数和复数</li>
<li>任意大小的整数和任意精度的浮点数</li>
<li>固定精度的十进制小数，常用于货币相关的场景</li>
</ul>
<p>好在社区已经开发出高质量的 Rust 数值库：<a href="https://crates.io/crates/num">num</a>。</p>
<p>按照以下步骤引入 <code>num</code> 库：</p>
<ol>
<li>创建新工程 <code>cargo new complex-num &amp;&amp; cd complex-num</code></li>
<li>在 <code>Cargo.toml</code> 中的 <code>[dependencies]</code> 下添加一行 <code>num = &quot;0.4.0&quot;</code></li>
<li>将 <code>src/main.rs</code> 文件中的 <code>main</code> 函数替换为下面的代码</li>
<li>运行 <code>cargo run</code></li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> num::complex::Complex;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">a</span> = Complex &#123; re: <span class="number">2.1</span>, im: -<span class="number">1.2</span> &#125;;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">b</span> = Complex::<span class="title function_ invoke__">new</span>(<span class="number">11.1</span>, <span class="number">22.2</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">result</span> = a + b;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; + &#123;&#125;i&quot;</span>, result.re, result.im)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符类型-char"><a href="#字符类型-char" class="headerlink" title="字符类型(char)"></a><a href="https://course.rs/basic/base-type/char-bool.html#字符类型char">字符类型(char)</a></h2><p>可以把它理解为英文中的字母，中文中的汉字。</p>
<p>了几个颇具异域风情的字符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = <span class="string">&#x27;ℤ&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g</span> = <span class="string">&#x27;国&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = &#x27;😻&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果大家是从有年代感的编程语言过来，可能会大喊一声：这 XX 叫字符？是的，在 Rust 语言中这些都是字符，Rust 的字符不仅仅是 <code>ASCII</code>，所有的 <code>Unicode</code> 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。<code>Unicode</code> 值的范围从 <code>U+0000 ~ U+D7FF</code> 和 <code>U+E000 ~ U+10FFFF</code>。不过“字符”并不是 <code>Unicode</code> 中的一个概念，所以人在直觉上对“字符”的理解和 Rust 的字符概念并不一致。</p>
<p>由于 <code>Unicode</code> 都是 4 个字节编码，因此字符类型也是占用 4 个字节：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;字符&#x27;中&#x27;占用了&#123;&#125;字节的内存大小&quot;</span>,std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling ...</span><br><span class="line"></span><br><span class="line">字符&#x27;中&#x27;占用了4字节的内存大小</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，和一些语言不同，Rust 的字符只能用 <code>&#39;&#39;</code> 来表示， <code>&quot;&quot;</code> 是留给字符串的。</p>
</blockquote>
<h2 id="布尔-bool"><a href="#布尔-bool" class="headerlink" title="布尔(bool)"></a><a href="https://course.rs/basic/base-type/char-bool.html#布尔bool">布尔(bool)</a></h2><p>Rust 中的布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>，布尔值占用内存的大小为 <code>1</code> 个字节：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">// 使用类型标注,显式指定f的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;这是段毫无意义的代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用布尔类型的场景主要在于流程控制，例如上述代码的中的 <code>if</code> 就是其中之一。</p>
<h2 id="单元类型"><a href="#单元类型" class="headerlink" title="单元类型"></a><a href="https://course.rs/basic/base-type/char-bool.html#单元类型">单元类型</a></h2><p>单元类型就是 <code>()</code> ，<code>main</code> 函数就返回这个单元类型 <code>()</code>，你不能说 <code>main</code> 函数无返回值，因为没有返回值的函数在 Rust 中是有单独的定义的：<code>发散函数( diverge function )</code>，顾名思义，无法收敛的函数。</p>
<p>例如常见的 <code>println!()</code> 的返回值也是单元类型 <code>()</code>。</p>
<p>你可以用 <code>()</code> 作为 <code>map</code> 的值，表示我们不关注具体的值，只关注 <code>key</code>。 这种用法和 Go 语言的 <strong><em>struct{}</em></strong> 类似，可以作为一个值用来占位，但是完全<strong>不占用</strong>任何内存。</p>
<h1 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a><a href="https://course.rs/basic/base-type/statement-expression.html#语句和表达式">语句和表达式</a></h1><p>Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_with_extra</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>; <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = y + <span class="number">5</span>; <span class="comment">// 语句</span></span><br><span class="line">    x + y <span class="comment">// 表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语句会执行一些操作但是不会返回一个值，而表达式会在求值后返回一个值，因此在上述函数体的三行代码中，前两行是语句，最后一行是表达式。</p>
<p>对于 Rust 语言而言，<strong>这种基于语句（statement）和表达式（expression）的方式是非常重要的，你需要能明确的区分这两个概念</strong>, 但是对于很多其它语言而言，这两个往往无需区分。基于表达式是函数式语言的重要特征，<strong>表达式总要返回值</strong>。</p>
<p>其实，在此之前，我们已经多次使用过语句和表达式。</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a><a href="https://course.rs/basic/base-type/statement-expression.html#语句">语句</a></h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: <span class="type">Vec</span>&lt;<span class="type">f64</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> (a, c) = (<span class="string">&quot;hi&quot;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>以上都是语句，它们完成了一个具体的操作，但是并没有返回值，因此是语句。</p>
<p>由于 <code>let</code> 是语句，因此不能将 <code>let</code> 语句赋值给其它值，如下形式是错误的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = (<span class="keyword">let</span> <span class="variable">a</span> = <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>错误如下:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">error: expected expression, found statement (`let`) // 期望表达式，却发现`let`语句</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:2:13</span></span><br><span class="line">  |</span><br><span class="line">2 |     let b = let a = 8;</span><br><span class="line">  |             ^^^^^^^^^</span><br><span class="line">  |</span><br><span class="line">  = note: variable declaration using `let` is a statement `let`是一条语句</span><br><span class="line"></span><br><span class="line">error[E0658]: `let` expressions in this position are experimental</span><br><span class="line">          // 下面的 `let` 用法目前是试验性的，在稳定版中尚不能使用</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:2:13</span></span><br><span class="line">  |</span><br><span class="line">2 |     let b = let a = 8;</span><br><span class="line">  |             ^^^^^^^^^</span><br><span class="line">  |</span><br><span class="line">  = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information</span><br><span class="line">  = help: you can write `matches!(&lt;expr&gt;, &lt;pattern&gt;)` instead of `let &lt;pattern&gt; = &lt;expr&gt;`</span><br></pre></td></tr></table></figure>
<p>以上的错误告诉我们 <code>let</code> 是语句，不是表达式，因此它不返回值，也就不能给其它变量赋值。</p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a><a href="https://course.rs/basic/base-type/statement-expression.html#表达式">表达式</a></h2><p>表达式会进行求值，然后返回一个值。例如 <code>5 + 6</code>，在求值后，返回值 <code>11</code>，因此它就是一条表达式。</p>
<p>表达式可以成为语句的一部分，例如 <code>let y = 6</code> 中，<code>6</code> 就是一个表达式，它在求值后返回一个值 <code>6</code>（有些反直觉，但是确实是表达式）。</p>
<p>调用一个函数是表达式，因为会返回一个值，调用宏也是表达式，用花括号包裹最终返回一个值的语句块也是表达式，总之，能返回值，它就是表达式:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面使用一个语句块表达式将值赋给 <code>y</code> 变量，语句块长这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该语句块是表达式的原因是：它的最后一行是表达式，返回了 <code>x + 1</code> 的值，注意 <code>x + 1</code> 不能以分号结尾，否则就会从表达式变成语句， <strong>表达式不能包含分号</strong>。这一点非常重要，一旦你在表达式后加上分号，它就会变成一条语句，再也<strong>不会</strong>返回一个值</p>
<p>最后，表达式如果不返回任何值，会隐式地返回一个 <a href="https://course.rs/basic/base-type/char-bool.html#单元类型"><code>()</code></a> 。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">ret_unit_type</span>(), ())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">ret_unit_type</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// if 语句块也是一个表达式，因此可以用于赋值，也可以直接返回</span></span><br><span class="line">    <span class="comment">// 类似三元运算符，在Rust里我们可以这样写</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="string">&quot;odd&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;even&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 或者写成一行</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">1</span> &#123; <span class="string">&quot;odd&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&quot;even&quot;</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a><a href="https://course.rs/basic/base-type/function.html#函数">函数</a></h1><p>在函数界，有一个函数只闻其名不闻其声，可以止小孩啼！在程序界只有 <code>hello,world!</code> 可以与之媲美，它就是 <code>add</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(i: <span class="type">i32</span>, j: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">   i + j</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>该函数如此简单，但是又是如此的五脏俱全，声明函数的关键字 <code>fn</code> ,函数名 <code>add()</code>，参数 <code>i</code> 和 <code>j</code>，参数类型和返回值类型都是 <code>i32</code></p>
<p><img src="https://pic2.zhimg.com/80/v2-54b3a6d435d2482243edc4be9ab98153_1440w.png" alt="img"></p>
<h2 id="函数要点"><a href="#函数要点" class="headerlink" title="函数要点"></a><a href="https://course.rs/basic/base-type/function.html#函数要点">函数要点</a></h2><ul>
<li>函数名和变量名使用<a href="https://course.rs/practice/naming.html">蛇形命名法(snake case)</a>，例如 <code>fn add_two() -&gt; &#123;&#125;</code></li>
<li>函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可</li>
<li>每个函数参数都需要标注类型</li>
</ul>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a><a href="https://course.rs/basic/base-type/function.html#函数参数">函数参数</a></h2><p>Rust 是强类型语言，因此需要你为每一个函数参数都标识出它的具体类型，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>, <span class="number">6.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>, y: <span class="type">f32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>another_function</code> 函数有两个参数，其中 <code>x</code> 是 <code>i32</code> 类型，<code>y</code> 是 <code>f32</code> 类型，然后在该函数内部，打印出这两个值。这里去掉 <code>x</code> 或者 <code>y</code> 的任何一个的类型，都会报错：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>, <span class="number">6.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>, y) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误如下:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">error: expected one of `:`, `@`, or `|`, found `)`</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:5:30</span></span><br><span class="line">  |</span><br><span class="line">5 | fn another_function(x: i32, y) &#123;</span><br><span class="line">  |                              ^ expected one of `:`, `@`, or `|` // 期待以下符号之一 `:`, `@`, or `|`</span><br><span class="line">  |</span><br><span class="line">  = note: anonymous parameters are removed in the 2018 edition (see RFC 1685)</span><br><span class="line">    // 匿名参数在 Rust 2018 edition 中就已经移除</span><br><span class="line">help: if this is a parameter name, give it a type // 如果y是一个参数名，请给予它一个类型</span><br><span class="line">  |</span><br><span class="line">5 | fn another_function(x: i32, y: TypeName) &#123;</span><br><span class="line">  |                             ~~~~~~~~~~~</span><br><span class="line">help: if this is a type, explicitly ignore the parameter name // 如果y是一个类型，请使用_忽略参数名</span><br><span class="line">  |</span><br><span class="line">5 | fn another_function(x: i32, _: y) &#123;</span><br><span class="line">  |                             ~~~~</span><br></pre></td></tr></table></figure>
<h2 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a><a href="https://course.rs/basic/base-type/function.html#函数返回">函数返回</a></h2><p>在上一章节语句和表达式中，我们有提到，在 Rust 中函数就是表达式，因此我们可以把函数的返回值直接赋给调用者。</p>
<p>函数的返回值就是函数体最后一条表达式的返回值，当然我们也可以使用 <code>return</code> 提前返回，下面的函数使用最后一条表达式来返回一个值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_five</span>(x:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">plus_five</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>x + 5</code> 是一条表达式，求值后，返回一个值，因为它是函数的最后一行，因此该表达式的值也是函数的返回值。</p>
<p>再来看两个重点：</p>
<ol>
<li><code>let x = plus_five(5)</code>，说明我们用一个函数的返回值来初始化 <code>x</code> 变量，因此侧面说明了在 Rust 中函数也是表达式，这种写法等同于 <code>let x = 5 + 5;</code></li>
<li><code>x + 5</code> 没有分号，因为它是一条表达式，这个在上一节中我们也有详细介绍</li>
</ol>
<p>再来看一段代码，同时使用 <code>return</code> 和表达式作为返回值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_or_minus</span>(x:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x - <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x + <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">plus_or_minus</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>plus_or_minus</code> 函数根据传入 <code>x</code> 的大小来决定是做加法还是减法，若 <code>x &gt; 5</code> 则通过 <code>return</code> 提前返回 <code>x - 5</code> 的值,否则返回 <code>x + 5</code> 的值。</p>
<h4 id="Rust-中的特殊返回类型"><a href="#Rust-中的特殊返回类型" class="headerlink" title="Rust 中的特殊返回类型"></a><a href="https://course.rs/basic/base-type/function.html#rust-中的特殊返回类型">Rust 中的特殊返回类型</a></h4><h5 id="无返回值"><a href="#无返回值" class="headerlink" title="无返回值()"></a><a href="https://course.rs/basic/base-type/function.html#无返回值">无返回值<code>()</code></a></h5><p>对于 Rust 新手来说，有些返回类型很难理解，而且如果你想通过百度或者谷歌去搜索，都不好查询，因为这些符号太常见了，根本难以精确搜索到。</p>
<p>例如单元类型 <code>()</code>，是一个零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值：</p>
<ul>
<li>函数没有返回值，那么返回一个 <code>()</code></li>
<li>通过 <code>;</code> 结尾的语句返回一个 <code>()</code></li>
</ul>
<p>例如下面的 <code>report</code> 函数会隐式返回一个 <code>()</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">report</span>&lt;T: <span class="built_in">Debug</span>&gt;(item: T) &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, item);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上面的函数返回值相同，但是下面的函数显式的返回了 <code>()</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">clear</span>(text: &amp;<span class="keyword">mut</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">  *text = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际编程中，经常在错误提示中看到该 <code>()</code> 的身影出没，假如你的函数需要返回一个 <code>u32</code> 值，但是如果你不幸的以 <code>表达式;</code> 的语句形式作为函数的最后一行代码，就会报错：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(x:<span class="type">u32</span>,y:<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">error[E0308]: mismatched types // 类型不匹配</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:6:24</span></span><br><span class="line">  |</span><br><span class="line">6 | fn add(x:u32,y:u32) -&gt; u32 &#123;</span><br><span class="line">  |    ---                 ^^^ expected `u32`, found `()` // 期望返回u32,却返回()</span><br><span class="line">  |    |</span><br><span class="line">  |    implicitly returns `()` as its body has no tail or `return` expression</span><br><span class="line">7 |     x + y;</span><br><span class="line">  |          - help: consider removing this semicolon</span><br></pre></td></tr></table></figure>
<p>还记得我们在<a href="https://course.rs/basic/base-type/statement-expression.html">语句与表达式</a>中讲过的吗？只有表达式能返回值，而 <code>;</code> 结尾的是语句，在 Rust 中，一定要严格区分<strong>表达式</strong>和<strong>语句</strong>的区别，这个在其它语言中往往是被忽视的点。</p>
<h5 id="永不返回的发散函数"><a href="#永不返回的发散函数" class="headerlink" title="永不返回的发散函数 !"></a><a href="https://course.rs/basic/base-type/function.html#永不返回的发散函数-">永不返回的发散函数 <code>!</code></a></h5><p>当用 <code>!</code> 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dead_end</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">  <span class="built_in">panic!</span>(<span class="string">&quot;你已经到了穷途末路，崩溃吧！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的函数创建了一个无限循环，该循环永不跳出，因此函数也永不返回：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">forever</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">  <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>这是一个demo</title>
    <url>/2023/10/26/demo/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>demo</category>
      </categories>
      <tags>
        <tag>demo</tag>
        <tag>示例</tag>
      </tags>
  </entry>
  <entry>
    <title>zfb+wx自动刷取步数</title>
    <url>/2024/02/27/auto_step/</url>
    <content><![CDATA[<h2 id="一、ZeepLife准备"><a href="#一、ZeepLife准备" class="headerlink" title="一、ZeepLife准备"></a>一、ZeepLife准备</h2><ol>
<li><p>手机下载<code>Zeep Life</code>APP，在应用商店都可以搜到</p>
<p><img src="https://s2.loli.net/2023/06/02/Y3LP1tUBTSFQrKa.jpg" alt="微信图片_20230602184001"></p>
</li>
<li><p>注册账号，尽量使用邮箱注册，并牢记用户名和密码</p>
<p><img src="https://s2.loli.net/2023/06/02/bK7WYP1AdmyQIcS.jpg" alt="微信图片_20230602183927"></p>
</li>
<li><p>登录</p>
<p><img src="https://s2.loli.net/2023/06/02/LRpIV84ou17GQFs.jpg" alt="微信图片_20230602183932"></p>
</li>
<li>App内我的-&gt;第三方接入，绑定微信 支付宝<blockquote>
<p>备注：同步微信运动请按照要求关注【华米科技】公众号</p>
</blockquote>
</li>
</ol>
<h2 id="二、实现模块"><a href="#二、实现模块" class="headerlink" title="二、实现模块"></a>二、实现模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests,time,re,json,random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">TG_BOT_TOKEN = <span class="string">&quot;*&quot;</span>           <span class="comment"># telegram bot token 自行申请</span></span><br><span class="line">TG_USER_ID = <span class="string">&quot;*&quot;</span>             <span class="comment"># telegram 用户ID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">telegram_bot</span>(<span class="params">title, content</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    tg_bot_token = TG_BOT_TOKEN</span><br><span class="line">    tg_user_id = TG_USER_ID</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;TG_BOT_TOKEN&quot;</span> <span class="keyword">in</span> os.environ <span class="keyword">and</span> <span class="string">&quot;TG_USER_ID&quot;</span> <span class="keyword">in</span> os.environ:</span><br><span class="line">        tg_bot_token = os.environ[<span class="string">&quot;TG_BOT_TOKEN&quot;</span>]</span><br><span class="line">        tg_user_id = os.environ[<span class="string">&quot;TG_USER_ID&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tg_bot_token <span class="keyword">or</span> <span class="keyword">not</span> tg_user_id:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Telegram推送的tg_bot_token或者tg_user_id未设置!!\n取消推送&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Telegram 推送开始&quot;</span>)</span><br><span class="line">    send_data = &#123;<span class="string">&quot;chat_id&quot;</span>: tg_user_id, <span class="string">&quot;text&quot;</span>: title +</span><br><span class="line">                 <span class="string">&#x27;\n\n&#x27;</span>+content, <span class="string">&quot;disable_web_page_preview&quot;</span>: <span class="string">&quot;true&quot;</span>&#125;</span><br><span class="line">    response = requests.post(</span><br><span class="line">        url=<span class="string">&#x27;https://api.telegram.org/bot%s/sendMessage&#x27;</span> % (tg_bot_token), data=send_data)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line"></span><br><span class="line">now = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Dalvik/2.1.0 (Linux; U; Android 9; MI 6 MIUI/20.6.18)&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取登录code</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_code</span>(<span class="params">location</span>):</span><br><span class="line">    code_pattern = re.<span class="built_in">compile</span>(<span class="string">&quot;(?&lt;=access=).*?(?=&amp;)&quot;</span>)</span><br><span class="line">    code = code_pattern.findall(location)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line"><span class="comment">#登录</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">user,password</span>):</span><br><span class="line">    url1 = <span class="string">&quot;https://api-user.huami.com/registrations/&quot;</span> + user + <span class="string">&quot;/tokens&quot;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;application/x-www-form-urlencoded;charset=UTF-8&quot;</span>,</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>:<span class="string">&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    data1 = &#123;</span><br><span class="line">        <span class="string">&quot;client_id&quot;</span>:<span class="string">&quot;HuaMi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>:<span class="string">f&quot;<span class="subst">&#123;password&#125;</span>&quot;</span>,</span><br><span class="line">        <span class="string">&quot;redirect_uri&quot;</span>:<span class="string">&quot;https://s3-us-west-2.amazonaws.com/hm-registration/successsignin.html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;token&quot;</span>:<span class="string">&quot;access&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    r1 = requests.post(url1,data=data1,headers=headers,allow_redirects=<span class="literal">False</span>)</span><br><span class="line">    location = r1.headers[<span class="string">&quot;Location&quot;</span>]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        code = get_code(location)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="comment">#print(&quot;access_code获取成功！&quot;)ste</span></span><br><span class="line">    <span class="comment">#print(code)</span></span><br><span class="line"></span><br><span class="line">    url2 = <span class="string">&quot;https://account.huami.com/v2/client/login&quot;</span></span><br><span class="line">    data2 = &#123;</span><br><span class="line">            <span class="string">&quot;allow_registration=&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;app_name&quot;</span>: <span class="string">&quot;com.xiaomi.hm.health&quot;</span>,</span><br><span class="line">            <span class="string">&quot;app_version&quot;</span>: <span class="string">&quot;6.3.5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;code&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;code&#125;</span>&quot;</span>,</span><br><span class="line">            <span class="string">&quot;country_code&quot;</span>: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">            <span class="string">&quot;device_id&quot;</span>: <span class="string">&quot;2C8B4939-0CCD-4E94-8CBA-CB8EA6E613A1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;device_model&quot;</span>: <span class="string">&quot;phone&quot;</span>,</span><br><span class="line">            <span class="string">&quot;dn&quot;</span>: <span class="string">&quot;api-user.huami.com%2Capi-mifit.huami.com%2Capp-analytics.huami.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;grant_type&quot;</span>: <span class="string">&quot;access_token&quot;</span>,</span><br><span class="line">            <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;zh_CN&quot;</span>,</span><br><span class="line">            <span class="string">&quot;os_version&quot;</span>: <span class="string">&quot;1.5.0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;source&quot;</span>: <span class="string">&quot;com.xiaomi.hm.health&quot;</span>,</span><br><span class="line">            <span class="string">&quot;third_name&quot;</span>: <span class="string">&quot;email&quot;</span>,</span><br><span class="line">        &#125; </span><br><span class="line">    r2 = requests.post(url2,data=data2,headers=headers).json()</span><br><span class="line">    login_token = r2[<span class="string">&quot;token_info&quot;</span>][<span class="string">&quot;login_token&quot;</span>]</span><br><span class="line">    <span class="comment">#print(&quot;login_token获取成功！&quot;)</span></span><br><span class="line">    <span class="comment">#print(login_token)</span></span><br><span class="line">    userid = r2[<span class="string">&quot;token_info&quot;</span>][<span class="string">&quot;user_id&quot;</span>]</span><br><span class="line">    <span class="comment">#print(&quot;userid获取成功！&quot;)</span></span><br><span class="line">    <span class="comment">#print(userid)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> login_token,userid</span><br><span class="line"></span><br><span class="line"><span class="comment">#主函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">user, passwd, step</span>):</span><br><span class="line">    user = <span class="built_in">str</span>(user)</span><br><span class="line">    password = <span class="built_in">str</span>(passwd)</span><br><span class="line">    step = <span class="built_in">str</span>(step)</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> password == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;用户名或密码填写有误！&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> step == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;已设置为随机步数（20000-29999）&quot;</span>)</span><br><span class="line">        step = <span class="built_in">str</span>(random.randint(<span class="number">20000</span>,<span class="number">29999</span>))</span><br><span class="line">    login_token = <span class="number">0</span></span><br><span class="line">    login_token,userid = login(user,password)</span><br><span class="line">    <span class="keyword">if</span> login_token == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;登陆失败！&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login fail!&quot;</span></span><br><span class="line"></span><br><span class="line">    t = get_time()</span><br><span class="line"></span><br><span class="line">    app_token = get_app_token(login_token)</span><br><span class="line"></span><br><span class="line">    today = time.strftime(<span class="string">&quot;%F&quot;</span>)</span><br><span class="line"></span><br><span class="line">    data_json = <span class="string">&#x27;%5B%7B%22data_hr%22%3A%22%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F9L%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2FVv%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F0v%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F9e%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F0n%5C%2Fa%5C%2F%5C%2F%5C%2FS%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F0b%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F1FK%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2FR%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F9PTFFpaf9L%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2FR%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F0j%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F9K%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2FOv%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2Fzf%5C%2F%5C%2F%5C%2F86%5C%2Fzr%5C%2FOv88%5C%2Fzf%5C%2FPf%5C%2F%5C%2F%5C%2F0v%5C%2FS%5C%2F8%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2FSf%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2Fz3%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F0r%5C%2FOv%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2FS%5C%2F9L%5C%2Fzb%5C%2FSf9K%5C%2F0v%5C%2FRf9H%5C%2Fzj%5C%2FSf9K%5C%2F0%5C%2F%5C%2FN%5C%2F%5C%2F%5C%2F%5C%2F0D%5C%2FSf83%5C%2Fzr%5C%2FPf9M%5C%2F0v%5C%2FOv9e%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2FS%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2Fzv%5C%2F%5C%2Fz7%5C%2FO%5C%2F83%5C%2Fzv%5C%2FN%5C%2F83%5C%2Fzr%5C%2FN%5C%2F86%5C%2Fz%5C%2F%5C%2FNv83%5C%2Fzn%5C%2FXv84%5C%2Fzr%5C%2FPP84%5C%2Fzj%5C%2FN%5C%2F9e%5C%2Fzr%5C%2FN%5C%2F89%5C%2F03%5C%2FP%5C%2F89%5C%2Fz3%5C%2FQ%5C%2F9N%5C%2F0v%5C%2FTv9C%5C%2F0H%5C%2FOf9D%5C%2Fzz%5C%2FOf88%5C%2Fz%5C%2F%5C%2FPP9A%5C%2Fzr%5C%2FN%5C%2F86%5C%2Fzz%5C%2FNv87%5C%2F0D%5C%2FOv84%5C%2F0v%5C%2FO%5C%2F84%5C%2Fzf%5C%2FMP83%5C%2FzH%5C%2FNv83%5C%2Fzf%5C%2FN%5C%2F84%5C%2Fzf%5C%2FOf82%5C%2Fzf%5C%2FOP83%5C%2Fzb%5C%2FMv81%5C%2FzX%5C%2FR%5C%2F9L%5C%2F0v%5C%2FO%5C%2F9I%5C%2F0T%5C%2FS%5C%2F9A%5C%2Fzn%5C%2FPf89%5C%2Fzn%5C%2FNf9K%5C%2F07%5C%2FN%5C%2F83%5C%2Fzn%5C%2FNv83%5C%2Fzv%5C%2FO%5C%2F9A%5C%2F0H%5C%2FOf8%5C%2F%5C%2Fzj%5C%2FPP83%5C%2Fzj%5C%2FS%5C%2F87%5C%2Fzj%5C%2FNv84%5C%2Fzf%5C%2FOf83%5C%2Fzf%5C%2FOf83%5C%2Fzb%5C%2FNv9L%5C%2Fzj%5C%2FNv82%5C%2Fzb%5C%2FN%5C%2F85%5C%2Fzf%5C%2FN%5C%2F9J%5C%2Fzf%5C%2FNv83%5C%2Fzj%5C%2FNv84%5C%2F0r%5C%2FSv83%5C%2Fzf%5C%2FMP%5C%2F%5C%2F%5C%2Fzb%5C%2FMv82%5C%2Fzb%5C%2FOf85%5C%2Fz7%5C%2FNv8%5C%2F%5C%2F0r%5C%2FS%5C%2F85%5C%2F0H%5C%2FQP9B%5C%2F0D%5C%2FNf89%5C%2Fzj%5C%2FOv83%5C%2Fzv%5C%2FNv8%5C%2F%5C%2F0f%5C%2FSv9O%5C%2F0ZeXv%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F1X%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F9B%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2FTP%5C%2F%5C%2F%5C%2F1b%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F0%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F9N%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2F%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%5C%2Fv7%2B%22%2C%22date%22%3A%222021-08-07%22%2C%22data%22%3A%5B%7B%22start%22%3A0%2C%22stop%22%3A1439%2C%22value%22%3A%22UA8AUBQAUAwAUBoAUAEAYCcAUBkAUB4AUBgAUCAAUAEAUBkAUAwAYAsAYB8AYB0AYBgAYCoAYBgAYB4AUCcAUBsAUB8AUBwAUBIAYBkAYB8AUBoAUBMAUCEAUCIAYBYAUBwAUCAAUBgAUCAAUBcAYBsAYCUAATIPYD0KECQAYDMAYB0AYAsAYCAAYDwAYCIAYB0AYBcAYCQAYB0AYBAAYCMAYAoAYCIAYCEAYCYAYBsAYBUAYAYAYCIAYCMAUB0AUCAAUBYAUCoAUBEAUC8AUB0AUBYAUDMAUDoAUBkAUC0AUBQAUBwAUA0AUBsAUAoAUCEAUBYAUAwAUB4AUAwAUCcAUCYAUCwKYDUAAUUlEC8IYEMAYEgAYDoAYBAAUAMAUBkAWgAAWgAAWgAAWgAAWgAAUAgAWgAAUBAAUAQAUA4AUA8AUAkAUAIAUAYAUAcAUAIAWgAAUAQAUAkAUAEAUBkAUCUAWgAAUAYAUBEAWgAAUBYAWgAAUAYAWgAAWgAAWgAAWgAAUBcAUAcAWgAAUBUAUAoAUAIAWgAAUAQAUAYAUCgAWgAAUAgAWgAAWgAAUAwAWwAAXCMAUBQAWwAAUAIAWgAAWgAAWgAAWgAAWgAAWgAAWgAAWgAAWREAWQIAUAMAWSEAUDoAUDIAUB8AUCEAUC4AXB4AUA4AWgAAUBIAUA8AUBAAUCUAUCIAUAMAUAEAUAsAUAMAUCwAUBYAWgAAWgAAWgAAWgAAWgAAWgAAUAYAWgAAWgAAWgAAUAYAWwAAWgAAUAYAXAQAUAMAUBsAUBcAUCAAWwAAWgAAWgAAWgAAWgAAUBgAUB4AWgAAUAcAUAwAWQIAWQkAUAEAUAIAWgAAUAoAWgAAUAYAUB0AWgAAWgAAUAkAWgAAWSwAUBIAWgAAUC4AWSYAWgAAUAYAUAoAUAkAUAIAUAcAWgAAUAEAUBEAUBgAUBcAWRYAUA0AWSgAUB4AUDQAUBoAXA4AUA8AUBwAUA8AUA4AUA4AWgAAUAIAUCMAWgAAUCwAUBgAUAYAUAAAUAAAUAAAUAAAUAAAUAAAUAAAUAAAUAAAWwAAUAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAeSEAeQ8AcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcBcAcAAAcAAAcCYOcBUAUAAAUAAAUAAAUAAAUAUAUAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcCgAeQAAcAAAcAAAcAAAcAAAcAAAcAYAcAAAcBgAeQAAcAAAcAAAegAAegAAcAAAcAcAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcCkAeQAAcAcAcAAAcAAAcAwAcAAAcAAAcAIAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcCIAeQAAcAAAcAAAcAAAcAAAcAAAeRwAeQAAWgAAUAAAUAAAUAAAUAAAUAAAcAAAcAAAcBoAeScAeQAAegAAcBkAeQAAUAAAUAAAUAAAUAAAUAAAUAAAcAAAcAAAcAAAcAAAcAAAcAAAegAAegAAcAAAcAAAcBgAeQAAcAAAcAAAcAAAcAAAcAAAcAkAegAAegAAcAcAcAAAcAcAcAAAcAAAcAAAcAAAcA8AeQAAcAAAcAAAeRQAcAwAUAAAUAAAUAAAUAAAUAAAUAAAcAAAcBEAcA0AcAAAWQsAUAAAUAAAUAAAUAAAUAAAcAAAcAoAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAYAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcBYAegAAcAAAcAAAegAAcAcAcAAAcAAAcAAAcAAAcAAAeRkAegAAegAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAEAcAAAcAAAcAAAcAUAcAQAcAAAcBIAeQAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcBsAcAAAcAAAcBcAeQAAUAAAUAAAUAAAUAAAUAAAUBQAcBYAUAAAUAAAUAoAWRYAWTQAWQAAUAAAUAAAUAAAcAAAcAAAcAAAcAAAcAAAcAMAcAAAcAQAcAAAcAAAcAAAcDMAeSIAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcAAAcBQAeQwAcAAAcAAAcAAAcAMAcAAAeSoAcA8AcDMAcAYAeQoAcAwAcFQAcEMAeVIAaTYAbBcNYAsAYBIAYAIAYAIAYBUAYCwAYBMAYDYAYCkAYDcAUCoAUCcAUAUAUBAAWgAAYBoAYBcAYCgAUAMAUAYAUBYAUA4AUBgAUAgAUAgAUAsAUAsAUA4AUAMAUAYAUAQAUBIAASsSUDAAUDAAUBAAYAYAUBAAUAUAUCAAUBoAUCAAUBAAUAoAYAIAUAQAUAgAUCcAUAsAUCIAUCUAUAoAUA4AUB8AUBkAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAAfgAA%22%2C%22tz%22%3A32%2C%22did%22%3A%22DA932FFFFE8816E7%22%2C%22src%22%3A24%7D%5D%2C%22summary%22%3A%22%7B%5C%22v%5C%22%3A6%2C%5C%22slp%5C%22%3A%7B%5C%22st%5C%22%3A1628296479%2C%5C%22ed%5C%22%3A1628296479%2C%5C%22dp%5C%22%3A0%2C%5C%22lt%5C%22%3A0%2C%5C%22wk%5C%22%3A0%2C%5C%22usrSt%5C%22%3A-1440%2C%5C%22usrEd%5C%22%3A-1440%2C%5C%22wc%5C%22%3A0%2C%5C%22is%5C%22%3A0%2C%5C%22lb%5C%22%3A0%2C%5C%22to%5C%22%3A0%2C%5C%22dt%5C%22%3A0%2C%5C%22rhr%5C%22%3A0%2C%5C%22ss%5C%22%3A0%7D%2C%5C%22stp%5C%22%3A%7B%5C%22ttl%5C%22%3A18272%2C%5C%22dis%5C%22%3A10627%2C%5C%22cal%5C%22%3A510%2C%5C%22wk%5C%22%3A41%2C%5C%22rn%5C%22%3A50%2C%5C%22runDist%5C%22%3A7654%2C%5C%22runCal%5C%22%3A397%2C%5C%22stage%5C%22%3A%5B%7B%5C%22start%5C%22%3A327%2C%5C%22stop%5C%22%3A341%2C%5C%22mode%5C%22%3A1%2C%5C%22dis%5C%22%3A481%2C%5C%22cal%5C%22%3A13%2C%5C%22step%5C%22%3A680%7D%2C%7B%5C%22start%5C%22%3A342%2C%5C%22stop%5C%22%3A367%2C%5C%22mode%5C%22%3A3%2C%5C%22dis%5C%22%3A2295%2C%5C%22cal%5C%22%3A95%2C%5C%22step%5C%22%3A2874%7D%2C%7B%5C%22start%5C%22%3A368%2C%5C%22stop%5C%22%3A377%2C%5C%22mode%5C%22%3A4%2C%5C%22dis%5C%22%3A1592%2C%5C%22cal%5C%22%3A88%2C%5C%22step%5C%22%3A1664%7D%2C%7B%5C%22start%5C%22%3A378%2C%5C%22stop%5C%22%3A386%2C%5C%22mode%5C%22%3A3%2C%5C%22dis%5C%22%3A1072%2C%5C%22cal%5C%22%3A51%2C%5C%22step%5C%22%3A1245%7D%2C%7B%5C%22start%5C%22%3A387%2C%5C%22stop%5C%22%3A393%2C%5C%22mode%5C%22%3A4%2C%5C%22dis%5C%22%3A1036%2C%5C%22cal%5C%22%3A57%2C%5C%22step%5C%22%3A1124%7D%2C%7B%5C%22start%5C%22%3A394%2C%5C%22stop%5C%22%3A398%2C%5C%22mode%5C%22%3A3%2C%5C%22dis%5C%22%3A488%2C%5C%22cal%5C%22%3A19%2C%5C%22step%5C%22%3A607%7D%2C%7B%5C%22start%5C%22%3A399%2C%5C%22stop%5C%22%3A414%2C%5C%22mode%5C%22%3A4%2C%5C%22dis%5C%22%3A2220%2C%5C%22cal%5C%22%3A120%2C%5C%22step%5C%22%3A2371%7D%2C%7B%5C%22start%5C%22%3A415%2C%5C%22stop%5C%22%3A427%2C%5C%22mode%5C%22%3A3%2C%5C%22dis%5C%22%3A1268%2C%5C%22cal%5C%22%3A59%2C%5C%22step%5C%22%3A1489%7D%2C%7B%5C%22start%5C%22%3A428%2C%5C%22stop%5C%22%3A433%2C%5C%22mode%5C%22%3A1%2C%5C%22dis%5C%22%3A152%2C%5C%22cal%5C%22%3A4%2C%5C%22step%5C%22%3A238%7D%2C%7B%5C%22start%5C%22%3A434%2C%5C%22stop%5C%22%3A444%2C%5C%22mode%5C%22%3A3%2C%5C%22dis%5C%22%3A2295%2C%5C%22cal%5C%22%3A95%2C%5C%22step%5C%22%3A2874%7D%2C%7B%5C%22start%5C%22%3A445%2C%5C%22stop%5C%22%3A455%2C%5C%22mode%5C%22%3A4%2C%5C%22dis%5C%22%3A1592%2C%5C%22cal%5C%22%3A88%2C%5C%22step%5C%22%3A1664%7D%2C%7B%5C%22start%5C%22%3A456%2C%5C%22stop%5C%22%3A466%2C%5C%22mode%5C%22%3A3%2C%5C%22dis%5C%22%3A1072%2C%5C%22cal%5C%22%3A51%2C%5C%22step%5C%22%3A1245%7D%2C%7B%5C%22start%5C%22%3A467%2C%5C%22stop%5C%22%3A477%2C%5C%22mode%5C%22%3A4%2C%5C%22dis%5C%22%3A1036%2C%5C%22cal%5C%22%3A57%2C%5C%22step%5C%22%3A1124%7D%2C%7B%5C%22start%5C%22%3A478%2C%5C%22stop%5C%22%3A488%2C%5C%22mode%5C%22%3A3%2C%5C%22dis%5C%22%3A488%2C%5C%22cal%5C%22%3A19%2C%5C%22step%5C%22%3A607%7D%2C%7B%5C%22start%5C%22%3A489%2C%5C%22stop%5C%22%3A499%2C%5C%22mode%5C%22%3A4%2C%5C%22dis%5C%22%3A2220%2C%5C%22cal%5C%22%3A120%2C%5C%22step%5C%22%3A2371%7D%2C%7B%5C%22start%5C%22%3A500%2C%5C%22stop%5C%22%3A511%2C%5C%22mode%5C%22%3A3%2C%5C%22dis%5C%22%3A1268%2C%5C%22cal%5C%22%3A59%2C%5C%22step%5C%22%3A1489%7D%2C%7B%5C%22start%5C%22%3A512%2C%5C%22stop%5C%22%3A522%2C%5C%22mode%5C%22%3A1%2C%5C%22dis%5C%22%3A152%2C%5C%22cal%5C%22%3A4%2C%5C%22step%5C%22%3A238%7D%5D%7D%2C%5C%22goal%5C%22%3A8000%2C%5C%22tz%5C%22%3A%5C%2228800%5C%22%7D%22%2C%22source%22%3A24%2C%22type%22%3A0%7D%5D&#x27;</span></span><br><span class="line"></span><br><span class="line">    finddate = re.<span class="built_in">compile</span>(<span class="string">r&#x27;.*?date%22%3A%22(.*?)%22%2C%22data.*?&#x27;</span>)</span><br><span class="line">    findstep = re.<span class="built_in">compile</span>(<span class="string">r&#x27;.*?ttl%5C%22%3A(.*?)%2C%5C%22dis.*?&#x27;</span>)</span><br><span class="line">    data_json = re.sub(finddate.findall(data_json)[<span class="number">0</span>], today, <span class="built_in">str</span>(data_json))</span><br><span class="line">    data_json = re.sub(findstep.findall(data_json)[<span class="number">0</span>], step, <span class="built_in">str</span>(data_json))</span><br><span class="line"></span><br><span class="line">    url = <span class="string">f&#x27;https://api-mifit-cn.huami.com/v1/data/band_data.json?&amp;t=<span class="subst">&#123;t&#125;</span>&#x27;</span></span><br><span class="line">    head = &#123;</span><br><span class="line">        <span class="string">&quot;apptoken&quot;</span>: app_token,</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    data = <span class="string">f&#x27;userid=<span class="subst">&#123;userid&#125;</span>&amp;last_sync_data_time=1597306380&amp;device_type=0&amp;last_deviceid=DA932FFFFE8816E7&amp;data_json=<span class="subst">&#123;data_json&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">    response = requests.post(url, data=data, headers=head).json()</span><br><span class="line">    <span class="comment">#print(response)</span></span><br><span class="line">    result = <span class="string">f&quot;<span class="subst">&#123;user[:<span class="number">4</span>]&#125;</span>****<span class="subst">&#123;user[-<span class="number">4</span>:]&#125;</span>: [<span class="subst">&#123;now&#125;</span>] 修改步数（<span class="subst">&#123;step&#125;</span>）&quot;</span>+ response[<span class="string">&#x27;message&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    qqtalk = <span class="string">&#x27;https://qmsg.zendee.cn/send/e6b0c2a37b9836dc40912ccd583618c7?msg=&#x27;</span> + <span class="string">&quot;修改步数：&quot;</span> + step + <span class="string">&quot;  &quot;</span> + response[</span><br><span class="line">        <span class="string">&#x27;message&#x27;</span>] + <span class="string">&#x27;&amp;qq=*&#x27;</span></span><br><span class="line">    requests.get(qqtalk)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="comment">#修改上方的KYE和QQ</span></span><br><span class="line"><span class="comment"># qqtalk = &#x27;https://qmsg.zendee.cn/send/输入你的kye?msg=&#x27; + &quot;修改步数：&quot; + step + &quot;  &quot; + response[</span></span><br><span class="line"><span class="comment">#        &#x27;message&#x27;] + &#x27;&amp;qq=输入你的qq号&#x27;</span></span><br><span class="line"><span class="comment">#获取时间戳</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_time</span>():</span><br><span class="line">    url = <span class="string">&#x27;http://api.m.taobao.com/rest/api3.do?api=mtop.common.getTimestamp&#x27;</span></span><br><span class="line">    response = requests.get(url,headers=headers).json()</span><br><span class="line">    t = response[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;t&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取app_token</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_app_token</span>(<span class="params">login_token</span>):</span><br><span class="line">    url = <span class="string">f&quot;https://account-cn.huami.com/v1/client/app_tokens?app_name=com.xiaomi.hm.health&amp;dn=api-user.huami.com%2Capi-mifit.huami.com%2Capp-analytics.huami.com&amp;login_token=<span class="subst">&#123;login_token&#125;</span>&quot;</span></span><br><span class="line">    response = requests.get(url,headers=headers).json()</span><br><span class="line">    app_token = response[<span class="string">&#x27;token_info&#x27;</span>][<span class="string">&#x27;app_token&#x27;</span>]</span><br><span class="line">    <span class="comment">#print(&quot;app_token获取成功！&quot;)</span></span><br><span class="line">    <span class="comment">#print(app_token)</span></span><br><span class="line">    <span class="keyword">return</span> app_token</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">event, context</span>):</span><br><span class="line"><span class="comment">#def main_handler():</span></span><br><span class="line">    <span class="comment"># 用户名（单用户的格式为 13800138000 ，多用户用#隔开，例如13800138000#13800138000#13800138000）</span></span><br><span class="line">    user = <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="comment"># 登录密码（用#隔开，例如123456#123456#123456）</span></span><br><span class="line">    passwd = <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="comment"># 要修改的步数，直接输入想要修改的步数值，留空为随机步数20000至29999之间</span></span><br><span class="line">    step = <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br><span class="line">    user_list = user.split(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    passwd_list = passwd.split(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    setp_array = step.split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(user_list) == <span class="built_in">len</span>(passwd_list):</span><br><span class="line">        push = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(user_list)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(setp_array) == <span class="number">2</span>:</span><br><span class="line">                step = <span class="built_in">str</span>(random.randint(<span class="built_in">int</span>(setp_array[<span class="number">0</span>]),<span class="built_in">int</span>(setp_array[<span class="number">1</span>])))</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">str</span>(step) == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                step = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            push += main(user_list[line], passwd_list[line], step) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        telegram_bot(<span class="string">&quot;小米运动&quot;</span>, push)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;用户名和密码数量不对&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="三、部署阿里云"><a href="#三、部署阿里云" class="headerlink" title="三、部署阿里云"></a>三、部署阿里云</h2><ol>
<li>注册<a href="https://common-buy.aliyun.com/?commodityCode=fc#/buy">阿里云函数</a> 免费开通阿里云函数服务<br>访问<a href="https://fcnext.console.aliyun.com/cn-shenzhen/services">服务列表</a> 随便选择一个国内地区，点击【创建服务】。随便写名称，日志和链路追踪不建议开<br><img src="https://s2.loli.net/2024/02/27/JlfqRBDQjhNpwKL.png" alt=""></li>
<li>点击创建函数 -&gt; 选择从零开始创建 -&gt; 随便填个名称 -&gt; 选择python3.6（其它都默认图中所示）<br><img src="https://s2.loli.net/2024/02/27/cI8jLxnHt5CrfZB.png" alt=""><br><img src="https://s2.loli.net/2024/02/27/Q4n5tDmF6xqeUpY.png" alt=""></li>
<li>往下拉配置触发器，选择定时触发器 -&gt; 随便填个名称 -&gt; 指定时间（如图中表示每天14点整开始运行，时间建议选择中午到下午）其它不用填，点击创建<br><img src="https://s2.loli.net/2024/02/27/uO3rzJELKZ9ySjh.png" alt=""></li>
<li>接着把函数代码复制到index.py里面，填上手机号密码 -&gt; 部署代码 -&gt; 测试函数，可以看到执行成功了<br><img src="https://s2.loli.net/2024/02/27/kRQPvc63FedrHh2.png" alt=""> <blockquote>
<p>备注：一定要先部署再测试</p>
</blockquote>
</li>
</ol>
<h2 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h2><p>  默认随机两到三万，刷的太多容易“失效”。步数太高的别参与微信排行榜，很容易被禁7天</p>
<p>  可以每天坐等到时间自动刷步，每日领取290g蚂蚁森林能量</p>
]]></content>
      <categories>
        <category>教程</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>演示</tag>
      </tags>
  </entry>
  <entry>
    <title>迪杰斯特拉算法</title>
    <url>/2024/02/08/dijkstra/</url>
    <content><![CDATA[<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p> 将起始节点标记为已访问，并将其距离设为 0。将所有其他节点的距离设为无穷大，表示未知距离。将一个空的优先级队列用于存储待处理的节点，并将起始节点放入队列中。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>  1、从优先级队列中选择距离最短的节点。<br>  2、对于该节点的每个邻居节点，计算从起始节点到该邻居节点的距离。如果经过当前节点到达邻居节点的路径距离比已知的距离短，则更新邻居节点的距离，并将其添加到优先级队列中。</p>
<h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>   当优先级队列为空时，所有节点的最短路径都已经计算完成。可以从起始节点到每个节点的距离信息中获取最短路径。</p>
<p>Dijkstra 算法的时间复杂度取决于使用的数据结构。当使用最小堆实现优先级队列时，Dijkstra 算法的时间复杂度为 O((V+E)logV)，其中 V 是节点数量，E 是边数量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">graph, start</span>):</span><br><span class="line">    <span class="comment"># 初始化节点到起始节点的距离为无穷大</span></span><br><span class="line">    distances = &#123;node: <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line">    <span class="comment"># 起始节点到自身的距离为 0    </span></span><br><span class="line">    distances[start] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用优先级队列存储节点和其对应的距离</span></span><br><span class="line">    priority_queue = [(<span class="number">0</span>, start)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> priority_queue:</span><br><span class="line">        <span class="comment"># 从优先级队列中取出当前距离最短的节点</span></span><br><span class="line">        current_distance, current_node = heapq.heappop(priority_queue)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果当前节点的距离大于已知距离，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> current_distance &gt; distances[current_node]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历当前节点的邻居节点</span></span><br><span class="line">        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph[current_node].items():</span><br><span class="line">            <span class="comment"># 计算从起始节点到邻居节点的距离</span></span><br><span class="line">            distance = current_distance + weight</span><br><span class="line">            <span class="comment"># 如果经过当前节点到达邻居节点的距离比已知的距离短，则更新邻居节点的距离</span></span><br><span class="line">            <span class="keyword">if</span> distance &lt; distances[neighbor]:</span><br><span class="line">                distances[neighbor] = distance</span><br><span class="line">                <span class="comment"># 将邻居节点加入优先级队列中</span></span><br><span class="line">                heapq.heappush(priority_queue, (distance, neighbor))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> distances</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="示例图"><a href="#示例图" class="headerlink" title="示例图"></a>示例图</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  graph = &#123;</span><br><span class="line">      <span class="string">&#x27;A&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">4</span>&#125;,</span><br><span class="line">      <span class="string">&#x27;B&#x27;</span>: &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">5</span>&#125;,</span><br><span class="line">      <span class="string">&#x27;C&#x27;</span>: &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;B&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">      <span class="string">&#x27;D&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  start_node = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">  shortest_distances = dijkstra(graph, start_node)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Shortest distances from node&quot;</span>, start_node + <span class="string">&quot;:&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(shortest_distances)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>普西拉之歌</title>
    <url>/2024/02/14/Priscilla/</url>
    <content><![CDATA[<div class="abc-music-sheet">X:1
T:alternate heads
M:C
L:1/8
U:n=!style=normal!
K:C treble style=rhythm
&quot;Am&quot; BBBB B2 B&gt;B | &quot;Dm&quot; B2 B/B/B &quot;C&quot; B4 |&quot;Am&quot; B2 nGnB B2 nGnA | &quot;Dm&quot; nDB/B/ nDB/B/ &quot;C&quot; nCB/B/ nCB/B/ |B8| B0 B0 B0 B0 |]
%%text This translates to:
[M:C][K:style=normal]
[A,EAce][A,EAce][A,EAce][A,EAce] [A,EAce]2 [A,EAce]&gt;[A,EAce] |[DAdf]2 [DAdf]/[DAdf]/[DAdf] [CEGce]4 |[A,EAce]2 GA [A,EAce] GA |D[DAdf]/[DAdf]/ D[DAdf]/[DAdf]/ C [CEGce]/[CEGce]/ C[CEGce]/[CEGce]/ |[CEGce]8 | [CEGce]2 [CEGce]2 [CEGce]2 [CEGce]2 |]
GAB2 !style=harmonic![gb]4|GAB2 [K: style=harmonic]gbgb|
[K: style=x]
C/A,/ C/C/E C/zz2|
w:Rock-y did-nt like that</div>
<h1 id="Priscilla-the-Callonetta’s-song"><a href="#Priscilla-the-Callonetta’s-song" class="headerlink" title="Priscilla the Callonetta’s song"></a>Priscilla the Callonetta’s song</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">陈年的伤痕 渴望温柔碰触</span><br><span class="line">依依缠绵 罔顾星象命数</span><br><span class="line">撕裂的心扉 你用爱缝补</span><br><span class="line">这缱绻交织命途 你我共偿赎</span><br><span class="line"></span><br><span class="line">晨曦 你自梦境逃离</span><br><span class="line">空余丁香与醋栗香气</span><br><span class="line">鸦羽般的秀发 在梦境中翻飞</span><br><span class="line">紫罗兰的眼 粼粼中哀泣 </span><br><span class="line"></span><br><span class="line">我愿随狼踪 踏入风暴汹涌</span><br><span class="line">寻觅真心 哪怕爱已成空</span><br><span class="line">即使这颗心 如磐石坚硬</span><br><span class="line">我仍拥抱你 无论天寒地冻 </span><br><span class="line"></span><br><span class="line">晨曦 你自梦境逃离</span><br><span class="line">空余丁香与醋栗香气</span><br><span class="line">鸦羽般的秀发 在梦境中翻飞</span><br><span class="line">紫罗兰的眼 粼粼中哀泣</span><br><span class="line"></span><br><span class="line">是否因命运 我们形影相逐</span><br><span class="line">又或爱太盲目 才甘受束缚</span><br><span class="line">故事的最初 心愿的低诉</span><br><span class="line">这不由自主倾慕 难道终碌碌 </span><br><span class="line"></span><br><span class="line">晨曦 你自梦境逃离</span><br><span class="line">空余丁香与醋栗香气</span><br><span class="line">鸦羽般的秀发 在梦境中翻飞</span><br><span class="line">紫罗兰的眼 粼粼中哀泣</span><br></pre></td></tr></table></figure>
<p>  <img src="https://s2.loli.net/2024/02/14/rqKEl4s3c8JDQmo.jpg" alt=""><br>  <img src="https://s2.loli.net/2024/02/15/ijQGDFWdpcRsE2e.gif" alt=""><br>  <img src="https://s2.loli.net/2024/02/15/3I4aY8lsSTCcrjO.gif" alt=""><br>    <mark class="hl-label red">我永远热爱珍珠翡翠白玉汤</mark>  <img class="inline-img" src="https://s2.loli.net/2024/02/14/3eaMTF7BzvwSQfd.jpg" style="height:150px" /></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>巫师三</tag>
        <tag>歌词</tag>
      </tags>
  </entry>
  <entry>
    <title>优化jiba分词效率Demo</title>
    <url>/2024/02/09/jieba/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_words</span>(<span class="params">content_list, stopword_set</span>):</span><br><span class="line">    cut_words_list = []</span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> mail <span class="keyword">in</span> content_list:</span><br><span class="line">        <span class="comment"># 使用 jieba.lcut_for_search 替代 jieba.lcut</span></span><br><span class="line">        cut_words = jieba.lcut_for_search(mail)</span><br><span class="line">        <span class="comment"># 使用集合进行停用词检查</span></span><br><span class="line">        cut_words = [word <span class="keyword">for</span> word <span class="keyword">in</span> cut_words <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> stopword_set]</span><br><span class="line">        cut_words_list.append(cut_words)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;jieba分词用时%.2f秒&#x27;</span> % (time.time() - start_time))</span><br><span class="line">    <span class="keyword">return</span> cut_words_list</span><br></pre></td></tr></table></figure>
<h1 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content_list = [<span class="string">&quot;邮件1的内容&quot;</span>, <span class="string">&quot;邮件2的内容&quot;</span>, <span class="string">&quot;邮件3的内容&quot;</span>]</span><br><span class="line">stopword_list = [<span class="string">&quot;停用词1&quot;</span>, <span class="string">&quot;停用词2&quot;</span>, <span class="string">&quot;停用词3&quot;</span>]</span><br><span class="line">stopword_set = <span class="built_in">set</span>(stopword_list)</span><br><span class="line"></span><br><span class="line">result = split_words(content_list, stopword_set)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>教程</category>
        <category>Jieba</category>
      </categories>
      <tags>
        <tag>demo</tag>
        <tag>Jieba</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title>出师表</title>
    <url>/2024/02/08/page/</url>
    <content><![CDATA[<p>臣亮言：<mark class="hl-label default">先帝</mark> 创业未半，而<mark class="hl-label blue">中道崩殂</mark> 。今天下三分，<mark class="hl-label pink">益州疲敝</mark> ，此诚<mark class="hl-label red">危急存亡之秋</mark> 也！然侍衞之臣，不懈于内；<mark class="hl-label purple">忠志之士</mark> ，忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>宫中、府中，俱为一体；陟罚臧否，不宜异同。若有<mark class="hl-label orange">作奸</mark> 、<mark class="hl-label green">犯科</mark> ，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之治；不宜偏私，使内外异法也。</p>
<div class="timeline pink"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p>
</div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-02</p>
</div></div><div class='timeline-item-content'><p>这是测试页面</p>
</div></div></div>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  
pie
    title Key elements in Product X
    &quot;Calcium&quot; : 42.96
    &quot;Potassium&quot; : 50.05
    &quot;Magnesium&quot; : 10.01
    &quot;Iron&quot; :  5
  </pre></div>
<p>你看我长得漂亮不</p>
<p><img src="https://i.loli.net/2021/03/19/2P6ivUGsdaEXSFI.png" alt=""></p>
<p>我觉得很漂亮 <img class="inline-img" src="https://i.loli.net/2021/03/19/5M4jUB3ynq7ePgw.png" style="height:150px" /></p>
]]></content>
      <categories>
        <category>demo</category>
      </categories>
      <tags>
        <tag>demo</tag>
        <tag>出师表</tag>
      </tags>
  </entry>
  <entry>
    <title>表情识别</title>
    <url>/2024/04/20/emotion/</url>
    <content><![CDATA[<h1 id="项目：人工智能-表情识别-DLBDSEAIS02"><a href="#项目：人工智能-表情识别-DLBDSEAIS02" class="headerlink" title="项目：人工智能-表情识别 (DLBDSEAIS02)"></a>项目：人工智能-表情识别 (DLBDSEAIS02)</h1><p>该项目利用 TensorFlow 作为主要框架，专注于使用卷积神经网络 (CNN) 从面部表情进行情绪检测。 TensorFlow 的部署功能（包括 TensorFlow Serving 和 TensorFlow Lite）可确保无缝过渡到生产。该工作流程涉及预处理管道，将 mma-facial-express 数据集的图像转换为 48x48 尺寸。 CNN 架构包括卷积层、最大池化、ReLU 激活、密集层和具有 Softmax 激活的全连接层。模型测试涉及准确率、召回率和精确率等指标，以及用于多分类的 F1“分数”。部署是通过 FastAPI 和 Docker 完成的，支持本地或基于云的执行。</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>为构建人工智能工具，利用图像中的面部表情来分析对广告的情绪反应。开发一个系统来对图像数据集中的情绪（例如快乐、愤怒、恐惧）进行分类。目标是通过面部表情识别至少三种情绪状态。</p>
<h1 id="开发规划-UML-模式"><a href="#开发规划-UML-模式" class="headerlink" title="开发规划 - UML 模式"></a>开发规划 - UML 模式</h1><h2 id="统一建模语言图"><a href="#统一建模语言图" class="headerlink" title="统一建模语言图"></a>统一建模语言图</h2><p>图（概念阶段修订）- 卷积神经网络的设计，用于分类情绪并使用 API 提供服务<br><img src="https://s2.loli.net/2024/04/20/ciCzGqohpR1lEK9.jpg" alt="Design of Convolutional Neural Network to classify emotions and serve using API"></p>
<p>创建的 Keras 序列模型是一个卷积神经网络 (CNN)，专为图像分类而设计，更具体地说，是对面部中存在的 7 种不同情绪进行分类。</p>
<p>该架构从具有 32 个滤波器的卷积层 (Conv2D_1) 开始，然后是批量归一化。随后，Conv2D_2 采用 64 个滤波器，具有 ReLU 激活和“相同”填充，并伴有批量归一化。 MaxPooling2D_1减少空间维度，Dropout_1防止过拟合。该模型还包括额外的几对卷积层和批量归一化层（Conv2D_3、BatchNormalization_3、Conv2D_4、BatchNormalization_4），每个层后面都有 MaxPooling 和 Dropout。该模式继续为 Conv2D_5、BatchNormalization_5、Conv2D_6、BatchNormalization_6、MaxPooling2D_3 和 Dropout_3。 Flattening 层为 Dense 层准备数据，从 Dense_1（2048 个单元，ReLU 激活）和 BatchNormalization_7 开始，然后是 Dropout_4。最终的 Dense_2 层利用 softmax 激活函数生成 7 个类别的输出概率。</p>
<p>该架构结合了卷积层和全连接层，通过批量归一化和 dropout 进行增强，以增强泛化并防止过度拟合。</p>
<h2 id="数据集概述"><a href="#数据集概述" class="headerlink" title="数据集概述"></a>数据集概述</h2><p>提供的图像数据集名为 MMAFEDB，分为三个主要文件夹：test、train 和 valid。每个文件夹都包含七种不同情绪的子文件夹：愤怒、厌恶、恐惧、快乐、中性、悲伤和惊讶。数据集统计显示，测试集包含 17,356 张图像，其中 13,767 张灰度图像，3,589 张 RGB 图像。训练集由 92,968 张图像组成，其中 64,259 张灰度图像，28,709 张 RGB 图像。验证集包含 17,356 张图像，其中 13,767 张灰度图像和 3,589 张 RGB 图像。数据集源自 Kaggle ( <a href="https://www.kaggle.com/datasets/mahmoudima/mma-facial-expression">https://www.kaggle.com/datasets/mahmoudima/mma-facial-expression</a> )。各组情绪的分布各不相同，其中中性情绪是最普遍的情绪。还可以在 1_dataset_exploration.ipynb 笔记本中找到以下结果，其中收集了有关数据集的见解，并且还对低于特定大小阈值的低质量图像进行了简要清理。</p>
<p>训练文件夹：</p>
<ul>
<li>中性：29,384 张图像</li>
<li>愤怒：6,566 张图片</li>
<li>恐惧：4,859 张图片</li>
<li>快乐：28,592 张图片</li>
<li>厌恶：3,231 张图片</li>
<li>悲伤：12,223 张图片</li>
<li>惊喜：8,113 张图片</li>
</ul>
<p>测试文件夹：</p>
<ul>
<li>中性：5,858 张图像</li>
<li>愤怒：1,041 张图片</li>
<li>恐惧：691 张图片</li>
<li>快乐：5,459 张图片</li>
<li>厌恶：655 张图片</li>
<li>悲伤：2,177 张图片</li>
<li>惊喜：1,475 张图片</li>
</ul>
<p>验证文件夹:</p>
<ul>
<li>中性：5,839 张图片</li>
<li>愤怒：1,017 张图片</li>
<li>恐惧：659 张图片</li>
<li>快乐：5,475 张图片</li>
<li>厌恶：656 张图片</li>
<li>悲伤：2,236 张图片</li>
<li>惊喜：1,474 张图片</li>
</ul>
<p>此细分提供了 MMAFEDB 数据集中每个文件夹的不同情绪图像分布的详细视图。</p>
<h1 id="模型开发"><a href="#模型开发" class="headerlink" title="模型开发"></a>模型开发</h1><h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>在 2_model_training_iterative.ipynb 中，使用清理后的数据集（不平衡情绪）训练四个不同的 Keras Sequential 模型。这些模型分别命名为 model_1_concept、model_2_best、model_3_best_nodropout 和 model_4_best_nodropout_nobatchn，是根据卷积神经网络 (CNN) 的初始概念和文献建议通过实验和调整而开发的。</p>
<p>该代码首先导入必要的模块，并为训练集和测试集创建 ImageDataGenerators 和 flow_from_directory 函数。模型架构在 JSON 文件中指定，代码读取这些文件以迭代构建每个 Keras 模型。这样可以轻松迭代不同的模型，并手动调整优化器和颜色模式（RGB 或灰度）。每个模型的训练历史记录都会被保存，从而实现性能和学习的跟踪和可视化。此外，模型架构保存在“diagram”文件夹中，检查点文件保存在改进的epoch上，最终模型保存为h5文件。</p>
<p>保存的文件格式的示例包括 <code>modelname</code> <em> <code>optimizer</code> </em> <code>colormode</code> <em> <code>batchsize</code> </em> <code>balanced vs standard</code> _ <code>history, final or cpt</code> . <code>filename_ext</code>:</p>
<ul>
<li>历史记录：model_1_concept_adam_grayscale_32_augment_history.json</li>
<li>最终模型：model_2_best_rmsprop_rgb_512_augment_final.h5</li>
<li>检查点：model_3_best_nodropout_rmsprop_rgb_512_augment_cpt.h5</li>
</ul>
<p>出于实用性的考虑，仅将性能最佳的模型保存在专用的“models/best_model”文件夹中，包括架构（JSON 文件）和权重（h5 文件）。</p>
<h2 id="模型指标和超参数"><a href="#模型指标和超参数" class="headerlink" title="模型指标和超参数"></a>模型指标和超参数</h2><p>在 3_training_evaluation.ipynb 中，对在清理后的数据集上训练的情绪识别模型进行了深入评估。分析首先导入模块并定义一个函数来识别每个模型的训练历史记录中的最高指标，例如准确度、损失、val_accuracy 和 val_loss。选择具有最高 val_accuracy 的模型（标识为“model_2_best_sgd_rgb_128”）进行进一步审查。实现了排名函数，创建一个根据 val_accuracy 对模型进行排名的数组。打印了前 10 个最佳模型和 5 个最差模型，提供了模型相对性能的快速概览。</p>
<p>随后，函数使用各种优化器和批量大小绘制不同的模型，比较 RGB 和灰度颜色模式的结果。此探索旨在考虑数据集的主要灰度图像，辨别使用任一颜色模式的任何明显效果。</p>
<p>为了详细了解最佳模型的性能，使用模型训练历史记录创建数据帧，捕获跨时期的指标（准确性、损失、val_accuracy、val_loss）。直方图说明了性能指标的分布，强调了最高的累积箱。 val_accuracy 与 epoch 的热图提供了有关模型学习速度的见解，颜色越亮表示学习速度越快。</p>
<p>此外，利用数据帧来查找按模型分组的最大值和最小值，从而提供训练历史记录的详细快照。最大值按 val_accuracy 降序排列，显示在数据框中。在所有模型中，确定了最低和最高值，从而提供对整体性能范围的深入了解。此外，还计算并可视化平均值、中位数和箱线图，以提供度量分布的概述。</p>
<p>然后，分析将重点转移到性能最佳的模型上，探究其训练和验证的准确性、损失和混淆矩阵。混淆矩阵突出了对角线上的正确预测，并暴露了预测某些情绪的挑战。分类报告提供详细的指标，揭示每个情感标签的 f1 分数、精确度、召回率和支持度。</p>
<p>接下来是微观和宏观平均 ROC 曲线分析，说明真阳性率和假阳性率与相应 AUC 值之间的权衡。最后，使用 batch_size = 1 的测试集对最佳模型进行评估，从而深入了解训练和验证的准确性。这种多方面的评估提供了对经过训练的情绪识别模型的全面理解，揭示了它们的优势、挑战和整体性能特征。</p>
<p><img src="https://s2.loli.net/2024/04/20/5IefN4L6FDp9UHB.png" alt="Model 1 Image"></p>
<p>迭代训练 4 个不同模型的结果在 /models 中:</p>
<ul>
<li><strong>model_1_concept</strong> - 概念阶段最初描述的模型</li>
<li><strong>model_2_best</strong> - 在尝试不同架构时发现的模型</li>
<li><strong>model_3_best_nodropout</strong> - 丢弃 model_2 中 dropout 的结果</li>
<li><strong>model_4_best_nodroupout_nobatchn</strong> - 从 model_2 中丢弃 dropout 和批量归一化的结果</li>
</ul>
<p>使用三个通道（RGB）进行图像输入，得到以下结果：<br><img src="https://s2.loli.net/2024/04/20/WsOkwRQz3YAPciU.jpg" alt="RGB Model Training Results"></p>
<p>使用一个通道（灰度）进行图像输入，得到以下结果：<br><img src="https://s2.loli.net/2024/04/20/mvp3s715AJubOBD.jpg" alt="GRAYSCALE Model Training Results"></p>
<p>可以看出，尽管大部分训练数据是灰度图像，但 RGB 训练结果稍好一些。该模型似乎从 RGB 数据中学习了仅通过一个通道无法获得的方面。</p>
<h2 id="平衡数据集"><a href="#平衡数据集" class="headerlink" title="平衡数据集"></a>平衡数据集</h2><p>我们尝试使用均衡数量的情感图像，以便每个类别都有相同的数量。从原始数据集中可以清楚地看出，某些情绪包含许多图像，而另一些情绪只占很小的比例。因此，我们探索了两种不同的平衡尝试，以了解增强的影响。首先，使用10.000 个图像的低阈值，以便图像数量较少的文件夹最终不会出现其原始图像的许多倍。最初，它被认为是更好的选择，因为太多的增强来达到其他类别的原始计数预计会产生不太好的结果。然而，平衡 2 数据集（所有图像类别都经过增强，每种情感达到30,000 张图像）表现更好。即使包含很少图像的情感，它仍然表现得更好。</p>
<p>可以在找到<code>4_balanced_emotions.ipynb</code> 和 <code>5_balanced_emotions_2.ipynb</code>. 首先，旧的增强被清理以返回到原始数据集。然后，对于未达到所需量的每种情绪，执行增强，然后文件夹达到所需量，例如 10,000 个图像。接下来，修剪超出所需数量的文件夹（首先删除尺寸最小的图像），以便在训练开始时所有文件夹都具有相同数量的图像。</p>
<p>这两幅图说明了增强是如何进行的。</p>
<p><strong>Balanced-1数据集 (每类 10.000 个图像)</strong><br><img src="https://s2.loli.net/2024/04/20/hC53aDe9TqJmozs.png" alt="Balanced-1 Dataset"><br><strong>Balanced-1 数据集(每类 30.000 个图像) - - 未更改，因为全部满足 30.000 个要求。</strong><br><img src="https://smms.app/image/xXD8VHOMy2uw1rc" alt="Balanced-2 Dataset"></p>
<p>模型经过训练，评估数据包含如下。</p>
<h2 id="最佳的表现模型"><a href="#最佳的表现模型" class="headerlink" title="最佳的表现模型"></a>最佳的表现模型</h2><p>根据最终的最大训练验证精度（val_accuracy）选择最佳模型。</p>
<p><strong>验证顶部和底部 5 个模型的准确性</strong><br><img src="https://s2.loli.net/2024/04/20/mTraQiGABK4klJp.png" alt="best_worst_models_val_accuracy"></p>
<p><strong>用于测试和验证的最高准确度和最低损失的箱线图</strong><br><img src="https://s2.loli.net/2024/04/20/eH472zFMPuURoaW.png" alt="boxenplot_highest_acc_lowest_loss"></p>
<p><strong>显示准确度的直方图分布，并突出显示最高条形（平均值）</strong><br><img src="https://s2.loli.net/2024/04/20/QoRkdDCEa3xJnmS.png" alt="histplot_val_accuracy_train_validate"></p>
<ul>
<li>al_accuracy最高的模型文件为:  <strong>../models/training/history/model_2_best_sgd_rgb_128_augment_history.json</strong></li>
<li>所有模型最大达到 val_accuracy 的平均值为: <strong>0.5652485278745493</strong></li>
<li>最高的val_accuracy（model_2_best_sgd_rgb_128）是: <strong>0.5928241014480591</strong></li>
</ul>
<p><strong>不平衡数据集的训练历史</strong><br><img src="https://s2.loli.net/2024/04/20/4Lx5BdVgzownPcW.png" alt="metrics model_2_best_sgd_rgb_128"><br>最佳模型的性能比平均 val_accuracy 训练验证好约 2.8%。</p>
<p>然而，如果我们在评估时使用批量大小 1，我们会发现最好的模型表现更好。<br>     评估模型的最终结果(batchsize = 1):<br>     训练准确度 = 83.28%<br>     验证准确度 = 63.52%</p>
<p><strong>Balanced-1 数据集的训练历史</strong><br><img src="https://s2.loli.net/2024/04/20/biVfj6sD2kBOKuJ.png" alt="metrics model_2_best_sgd_rgb_128 balanced"></p>
<p><strong>Balanced-2 数据集的训练历史</strong><br><img src="https://s2.loli.net/2024/04/20/4evM96YsPZlotBT.png" alt="metrics model_2_best_sgd_rgb_128 balanced 2"></p>
<h2 id="分类图"><a href="#分类图" class="headerlink" title="分类图"></a>分类图</h2><ul>
<li>A -  最佳模型不平衡</li>
<li>B - 最佳模型 Balanced-1 数据集</li>
<li>C - 最佳模型 Balanced-2 数据集</li>
</ul>
<h3 id="ROC曲线"><a href="#ROC曲线" class="headerlink" title="ROC曲线"></a>ROC曲线</h3><p><img src="https://s2.loli.net/2024/04/20/OBAdhZg3zPLKEHc.png" alt="ROC Curve for the best model unbalanced &amp; balanced emotions"></p>
<h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><p><img src="https://s2.loli.net/2024/04/20/rDj8kAc23nehPRS.png" alt="Confusion Matrixes for the best model unbalanced &amp; balanced emotions"></p>
<h3 id="分类报告"><a href="#分类报告" class="headerlink" title="分类报告"></a>分类报告</h3><p><img src="https://s2.loli.net/2024/04/20/hJ5VzDqln7wCNc1.png" alt="Classification Report for the best model unbalanced &amp; balanced emotions"></p>
<h1 id="Docker-API-前端"><a href="#Docker-API-前端" class="headerlink" title="Docker API 前端"></a>Docker API 前端</h1><h3 id="参阅-docker-api中的更多信息"><a href="#参阅-docker-api中的更多信息" class="headerlink" title="参阅 docker-api中的更多信息"></a>参阅 docker-api中的更多信息</h3><p>重新训练的模型使用 Balanced-2 数据集的情感图像进行预测。</p>
<ul>
<li>用户从他们的设备中选择一个文件</li>
<li>用户点击预测</li>
<li>显示预测情绪和类别概率。<br><img src="https://s2.loli.net/2024/04/20/cGKxsQ8ieOv3NUD.png" alt="docker-api front-end"></li>
</ul>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="使用-Jupyter-Notebook-的依赖项-注意，如果不存在-CUDA-GPU，它将默认使用-CPU（速度慢）"><a href="#使用-Jupyter-Notebook-的依赖项-注意，如果不存在-CUDA-GPU，它将默认使用-CPU（速度慢）" class="headerlink" title="使用 Jupyter Notebook 的依赖项 - 注意，如果不存在 CUDA GPU，它将默认使用 CPU（速度慢）"></a>使用 Jupyter Notebook 的依赖项 - 注意，如果不存在 CUDA GPU，它将默认使用 CPU（速度慢）</h2><p>创建一个新的虚拟 python 环境。</p>
<p><code>python3 -m venv venv</code></p>
<p>激活环境</p>
<p><code>source venv/bin/activate</code></p>
<p>安装依赖项</p>
<p><code>pip3 install -r requirements.txt</code></p>
<h2 id="使用预构建-docker-镜像的-API-使用"><a href="#使用预构建-docker-镜像的-API-使用" class="headerlink" title="使用预构建 docker 镜像的 API 使用"></a>使用预构建 docker 镜像的 API 使用</h2><h3 id="拉取最新的构建镜像"><a href="#拉取最新的构建镜像" class="headerlink" title="拉取最新的构建镜像"></a>拉取最新的构建镜像</h3><p><code>docker pull dadazhang55/emotion_tensorflow:latest</code></p>
<h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p><code>docker run --name emotion_prediction_container -p 8000:8000 emotion_prediction_fastapi:latest</code></p>
<h3 id="在本地主机上打开-API"><a href="#在本地主机上打开-API" class="headerlink" title="在本地主机上打开 API"></a>在本地主机上打开 API</h3><p><code>http://127.0.0.1:8000</code></p>
<h1 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h1><p>最初，使用 CUDA 驱动程序很麻烦，而且要反复试验才能让我的 NVIDIA GPU 正常工作，这是我面临的最大挑战。在使用卷积神经网络开发情感分析的过程中，我了解了模型架构（卷积层/最大池/dropout/批量归一化）、优化器和损失函数。</p>
<p>此外，如何使用不同的指标来衡量模型性能，以捕获训练历史并评估所使用的所有不同参数的影响。我的目标是创建一个以清晰且针对特定目的的方式组织的项目结构，并将权重和捕获的模型指标保存在指定的文件夹和文件中。通过这个过程，我更好地了解了如何以迭代方式保存和训练模型，以及如何在后期训练中恢复模型并与架构或仅训练的权重一起保存，以及如何使用这些文件。</p>
<p>我们发现，以 RGB 颜色训练时，包含大部分灰度图像和次要部分 RGB 图像的图像数据集似乎仍然表现更好。通过阅读不同的文献和在线材料，我了解了 dropout 和批量归一化如何显着提高泛化能力和性能。</p>
<p>使用不同的可视化对我训练的模型进行评估；例如，混淆矩阵、分类报告（f1 分数、召回率、精确度、准确度）让我很好地了解了模型的表现、意味着什么并确定了潜在的改进领域。通过图像增强平衡数据集让我学会了如何平衡图像类，但是它并没有显着改善我的不平衡数据集，这肯定是我在未来项目中更多探索和优化的领域。</p>
<p>最后，使用 FastAPI 和 Docker 构建一个简单的 api， 让我从用户的角度思考，调用 API 或使用前端网站与我训练的模型进行交互。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>该项目基于评估整个测试集，使用不平衡模型对情感图像进行了平均 63.52% 的分类。(<a href="https://www.kaggle.com/datasets/mahmoudima/mma-facial-expression/code">https://www.kaggle.com/datasets/mahmoudima/mma-facial-expression/code</a>). </p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试-功能测试的常用方法</title>
    <url>/2024/03/16/software_testing/</url>
    <content><![CDATA[<!-- [toc] -->
<h1 id="功能测试的常用方法"><a href="#功能测试的常用方法" class="headerlink" title="功能测试的常用方法"></a>功能测试的常用方法</h1><blockquote>
<p>这是一个有两段的块引用。这是第一段。</p>
<blockquote>
<p>这是第二段。Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. </p>
<blockquote>
<p>这是另一个只有一个段落的块引用。有三个空行分隔两个块引用。</p>
</blockquote>
</blockquote>
</blockquote>
<ol>
<li><p>页面链接检查，每一个链接是否有对应的界面</p>
</li>
<li><p>相关性检查，删除/增加一项会不会对其他项产生影响，如果产生影响，是否正确</p>
</li>
<li><p>检查按钮功能是否正确</p>
</li>
<li><p>字符串长度检查，输入超出需求所说明的字符串长度的内容，看系统是否检查，会不会出错。</p>
</li>
<li><p>字符类型检查</p>
</li>
<li><p>标点符号检查</p>
</li>
<li><p>中文字符处理，乱码或出错</p>
</li>
<li><p>检查带出信息的完整性，在查看信息和更新信息时,查看所填写的信息是不是全部带出,带出信息和添加的是否一致</p>
</li>
<li><p>信息重复，在一些需要命名，且名字唯一的信息输入重复的名字或ID，看系统有没有处理，重名包括是否区分大小写，以及在输入内容的前后输入空格，看系统是否处理。</p>
</li>
<li><p>检查删除功能，在一些可删除多个的地方，不选任何内容按删除按钮看系统如何处理 </p>
</li>
<li><p>选择一个或多个时又如何处理</p>
</li>
<li><p>检查添加修改是否一致，检查添加和修改信息的要求是否一致,例如添加要求必填的项,修改也应该必填;添加规定为整型的项,修改也必须为整型。</p>
</li>
<li><p>检查修改重名，修改时把不能重名的项改为已存在的内容，看会否处理，报错，同时看会否报和自己重名的错。</p>
</li>
<li><p>重复提交表单，一条已成功提交的记录，back后在提交，看系统是否进行处理。</p>
</li>
<li><p>检查多次处理back键的情况</p>
</li>
<li><p>搜索检查: 在有搜索功能的地方输入系统存在和不存在的内容，看结果是否正确</p>
</li>
<li><p>如果可以输入多个搜索条件，同时可以添加合理和不合理的条件，看系统是否处理正确。</p>
</li>
<li><p>输入信息的位置，输入信息时，光标的位置</p>
</li>
<li><p>上传和下载文件的检查，上传下载的功能是否实现，上传文件是否能打开，上传文件的格式规定，系统是否有解释信息。</p>
</li>
<li><p>必填项检查，必填项是否有提示信息</p>
</li>
<li><p>快捷键检查，是否支持常用快捷键检查</p>
</li>
</ol>
<h1 id="功能测试大全"><a href="#功能测试大全" class="headerlink" title="功能测试大全"></a>功能测试大全</h1><h2 id="一、在测试过程中所用到的测试方法"><a href="#一、在测试过程中所用到的测试方法" class="headerlink" title="一、在测试过程中所用到的测试方法"></a>一、在测试过程中所用到的测试方法</h2><ol>
<li>输入非法数据；</li>
<li>输入默认值；</li>
<li>输入特殊字符集；</li>
<li>输入使缓冲区溢出的数据；</li>
<li>输入相同的文件名；</li>
</ol>
<h2 id="二、登陆"><a href="#二、登陆" class="headerlink" title="二、登陆"></a>二、登陆</h2><ol>
<li>用户名和密码都符合要求（格式上的要求）</li>
<li>用户名和密码都不符合要求（格式上的要求）</li>
<li>用户名符合要求，密码不符合要求（格式上的要求）</li>
<li>密码符合要求，用户名不符合要求（格式上的要求）</li>
<li>用户名或密码为空</li>
<li>数据库中不存在的用户名，不存在的密码</li>
<li>数据库中存在的用户名，错误的密码</li>
<li>数据库中不存在的用户名，存在的密码</li>
<li>输入的数据前存在空格</li>
<li>输入正确的用户名密码以后按[enter]是否能登陆</li>
<li>输入的密码是否以*显示</li>
<li>输入密码错误次数是否有限制</li>
<li>密码输入框测试时要特别注意进行字母大写输入的测试</li>
</ol>
<h2 id="三、添加"><a href="#三、添加" class="headerlink" title="三、添加"></a>三、添加</h2><ol>
<li>要添加的数据项均合理，检查数据库中是否添加了相应的数据</li>
<li>留出一个必填数据为空</li>
<li>按照边界值等价类设计测试用例的原则设计其他输入项的测试用例 </li>
<li>不符合要求的地方要有错误提示</li>
<li>是否支持table键</li>
<li>按enter是否能保存</li>
<li>若提示不能保存，也要察看数据库里是否多了一条数据</li>
<li>如果存在两条相同的记录是否也能添加成功</li>
</ol>
<h2 id="四、删除"><a href="#四、删除" class="headerlink" title="四、删除"></a>四、删除</h2><ol>
<li>删除一个数据库中存在的数据，然后查看数据库中是否删除</li>
<li>删除一个数据库中并不存在的数据，看是否有错误提示，并且数据库中没有数据被删除 </li>
<li>输入一个格式错误的数据，看是否有错误提示，并且数据库中没有数据被删除</li>
<li>输入的正确数据前加空格，看是否能正确删除数据</li>
<li>什么也不输入</li>
<li>是否支持table键</li>
<li>是否支持enter键</li>
<li>若记录与其它表的数据有关联，是否允许删除</li>
</ol>
<h2 id="五、查询"><a href="#五、查询" class="headerlink" title="五、查询"></a>五、查询</h2><h3 id="一、精确查询"><a href="#一、精确查询" class="headerlink" title="一、精确查询"></a>一、精确查询</h3><ol>
<li>输入的查询条件为数据库中存在的数据，看是否能正确地查出相应得数据 </li>
<li>输入正确的查询条件前加上空格，看是否能正确地查出相应的数据 </li>
<li>输入格式或范围不符合要求的数据，看是否有错误提示</li>
<li>输入数据库中不存在的数据</li>
<li>不输入任何数据</li>
<li>是否支持table键</li>
<li>是否支持enter键</li>
<li>要关注组合查询和分页控件</li>
</ol>
<h3 id="二、模糊查询"><a href="#二、模糊查询" class="headerlink" title="二、模糊查询"></a>二、模糊查询</h3><p>输入一些字符，看是否能查出数据库中所有的相关信息</p>
<h2 id="六、设计功能和界面测试用例"><a href="#六、设计功能和界面测试用例" class="headerlink" title="六、设计功能和界面测试用例"></a>六、设计功能和界面测试用例</h2><h3 id="一、文本框、按钮等控件测试"><a href="#一、文本框、按钮等控件测试" class="headerlink" title="一、文本框、按钮等控件测试"></a>一、文本框、按钮等控件测试</h3><h4 id="文本框的测试"><a href="#文本框的测试" class="headerlink" title="文本框的测试"></a>文本框的测试</h4><ol>
<li>输入正常的字母或数字</li>
<li>输入已存在的文件的名称</li>
<li>输入超长字符。例如在“名称”框中输入超过允许边界个数的字符，假设最多255个字符，尝试输入256个字符，检查程序能否正确处理</li>
<li>输入默认值，空白，空格</li>
<li>若只允许输入字母，尝试输入数字；反之；尝试输入字母</li>
<li>利用复制，粘贴等操作强制输入程序不允许的输入数据</li>
<li>输入特殊字符集，例如，NUL及\n 等</li>
<li>输入超过文本框长度的字符或文本，检查所输入的内容是否正常显示</li>
<li>输入不符合格式的数据，检查程序是否正常校验，如，程序要求输入年月日格式为yy/mm/dd，实际输入yyyy/mm/dd，程序应该给出错误提示</li>
</ol>
<h4 id="命令按钮控件的测试"><a href="#命令按钮控件的测试" class="headerlink" title="命令按钮控件的测试"></a>命令按钮控件的测试</h4><ol>
<li>点击按钮正确响应操作。如，单击确定，正确执行操作；单击取消，退出窗口</li>
<li>对非法的输入或操作给出足够的提示说明，如 ，输入月工作天数为32时，单击”确定“后系统应提示：天数不能大于31</li>
<li>对可能造成数据无法恢复的操作必须给出确认信息，给用户放弃选择的机会</li>
</ol>
<h4 id="单选按钮控件的测试"><a href="#单选按钮控件的测试" class="headerlink" title="单选按钮控件的测试"></a>单选按钮控件的测试</h4><ol>
<li>一组单选按钮不能同时选中，只能选中一个</li>
<li>逐一执行每个单选按钮的功能。分别选择了“男”“女”后，保存到数据库的数据应该相应的分别为“男” “女”</li>
<li>一组执行同一功能的单选按钮在初始状态时必须有一个被默认选中，不能同时为空</li>
</ol>
<h4 id="控件文本框的测试"><a href="#控件文本框的测试" class="headerlink" title="控件文本框的测试"></a>控件文本框的测试</h4><ol>
<li>接输入数字或用上下箭头控制，如，在“数目”中直接输入10，或者单击向上的箭头，使数目变为10</li>
<li>利用上下箭头控制数字的自动循环，如，当最多数字为253时，单击向上箭头，数目自动变为1；反之亦适用</li>
<li>直接输入超边界值，系统应该提示重新输入</li>
<li>输入默认值，空白。如，“插入”数目为默认值，点击“确定”；或，删除默认值，使内容为空，单击“确定”进行测试</li>
<li>输入字符，此时系统应提示输入有误</li>
</ol>
<h4 id="组合列表框的测试"><a href="#组合列表框的测试" class="headerlink" title="组合列表框的测试"></a>组合列表框的测试</h4><ol>
<li>条目内容正确，其详细条目内容可以根据需求说明确定</li>
<li>逐一执行列表框中每个条目的功能</li>
<li>检查能否向组合列表框输入数据</li>
</ol>
<h4 id="复选框的测试"><a href="#复选框的测试" class="headerlink" title="复选框的测试"></a>复选框的测试</h4><ol>
<li>多个复选框可以被同时选中</li>
<li>多个复选框可以被部分选中</li>
<li>多个复选框可以都不被选中</li>
<li>逐一执行每个复选框的功能</li>
</ol>
<h4 id="列表框控件的测试"><a href="#列表框控件的测试" class="headerlink" title="列表框控件的测试"></a>列表框控件的测试</h4><ol>
<li>条目内容正确；同组合列表框类似，根据需求说明书确定列表的各项内容正确，没有丢失或错误</li>
<li>列表框的内容较多时要使用滚动条</li>
<li>列表框允许多选时，要分别检查shift选中条目，按ctrl选中条目和直接用鼠标选中多项条目的情况</li>
</ol>
<h4 id="滚动条控件的测试"><a href="#滚动条控件的测试" class="headerlink" title="滚动条控件的测试"></a>滚动条控件的测试</h4><ol>
<li>滚动条的长度根据显示信息的长度或宽度及时变换，这样有利于用户了解显示信息的位置和百分比，如，word中浏览100页文档，浏览到50页时，滚动条位置应处于中间</li>
<li>拖动滚动条，检查屏幕刷新情况，并查看是否有乱码</li>
<li>单击滚动条</li>
<li>用滚轮控制滚动条</li>
<li>滚动条的上下按钮</li>
</ol>
<h4 id="各种控件在窗体中混和使用时的测试"><a href="#各种控件在窗体中混和使用时的测试" class="headerlink" title="各种控件在窗体中混和使用时的测试"></a>各种控件在窗体中混和使用时的测试</h4><ol>
<li>控件间的相互作用</li>
<li>tab键的顺序，一般是从上到下，从左到右</li>
<li>热键的使用，逐一测试</li>
<li>enter键和esc键的使用</li>
</ol>
<h3 id="二、查找替换操作"><a href="#二、查找替换操作" class="headerlink" title="二、查找替换操作"></a>二、查找替换操作</h3><h4 id="通过测试"><a href="#通过测试" class="headerlink" title="通过测试"></a>通过测试</h4><ol>
<li>输入内容直接查找，或查找全部</li>
<li>在组合框中寻找已经查找过的内容，再次查找并确认文档的内容正确，如，已经查找过”测试用例”，再次进入不用重新输入查找内容，直接在文档中搜寻就可以</li>
</ol>
<h4 id="失败测试"><a href="#失败测试" class="headerlink" title="失败测试"></a>失败测试</h4><ol>
<li>输入过长或过短的查询字符串.如，假设查询的字符串长度为1到255，那么输入0，1，2，256，255和254进行测试</li>
<li>输入特殊字符集，如，在word中.^g代表图片，^代表分栏符，可以输入这类特殊字符测试；  替换测试大体相同</li>
</ol>
<h4 id="编辑操作窗口的测试"><a href="#编辑操作窗口的测试" class="headerlink" title="编辑操作窗口的测试"></a>编辑操作窗口的测试</h4><ol>
<li>关闭查找替换窗口.不执行任何操作，直接退出</li>
<li>附件和选项测试.假如，设定”精确搜寻”，”向后”搜索等附件选项等等来测试</li>
<li>控件间的相互作用.如，搜寻内容为空时，按钮”搜寻全部”，”搜寻”，”全部替换”，”替换”都为灰色</li>
<li>热键，Tab键.回车键的使用</li>
</ol>
<h3 id="三、插入操作"><a href="#三、插入操作" class="headerlink" title="三、插入操作"></a>三、插入操作</h3><h4 id="插入文件-测试的情况"><a href="#插入文件-测试的情况" class="headerlink" title="插入文件 测试的情况"></a>插入文件 测试的情况</h4><ol>
<li>插入文件</li>
<li>插入图像</li>
<li>在文档中插入文档本身</li>
<li>移除插入的源文件</li>
<li>更换插入的源文件的内容</li>
</ol>
<h4 id="链接文件-测试方法"><a href="#链接文件-测试方法" class="headerlink" title="链接文件 测试方法"></a>链接文件 测试方法</h4><ol>
<li>插入链接文件</li>
<li>在文档中链接文档本身</li>
<li>移除插入的源文件</li>
<li>更换插入的源文件的内容</li>
</ol>
<h4 id="插入对象-要测试的内容"><a href="#插入对象-要测试的内容" class="headerlink" title="插入对象 要测试的内容"></a>插入对象 要测试的内容</h4><ol>
<li>插入程序允许的对象，如，在word中插入excel工作表</li>
<li>修改所插入对象的内容.插入的对象仍能正确显示</li>
<li>卸载生成插入对象的程序，如，在word中插入excel工作表后卸载excel，工作表仍正常使用</li>
</ol>
<h3 id="四、编辑操作"><a href="#四、编辑操作" class="headerlink" title="四、编辑操作"></a>四、编辑操作</h3><h4 id="测试剪切操作的方法"><a href="#测试剪切操作的方法" class="headerlink" title="测试剪切操作的方法"></a>测试剪切操作的方法</h4><ol>
<li>对文本，文本框，图文框进行剪切</li>
<li>剪切图像</li>
<li>文本图像混合剪切</li>
</ol>
<h4 id="复制操作方法"><a href="#复制操作方法" class="headerlink" title="复制操作方法"></a>复制操作方法</h4><ol>
<li>粘贴剪切的文本，文本框及图文框</li>
<li>粘贴所剪切的图像</li>
<li>剪切后，在不同的程序中粘贴</li>
<li>多次粘贴同一内容，如，剪切后，在程序中连续粘贴3次</li>
<li>利用粘贴操作强制输入程序所不允许输入的数据</li>
</ol>
<h3 id="五、界面测试用例"><a href="#五、界面测试用例" class="headerlink" title="五、界面测试用例"></a>五、界面测试用例</h3><h4 id="窗体-测试窗体的方法"><a href="#窗体-测试窗体的方法" class="headerlink" title="窗体 测试窗体的方法"></a>窗体 测试窗体的方法</h4><ol>
<li>窗体大小，大小要合适，控件布局合理</li>
<li>移动窗体.快速或慢速移动窗体，背景及窗体本身刷新必须正确</li>
<li>缩放窗体，窗体上的控件应随窗体的大小变化而变化</li>
<li>显示分辨率.必须在不同的分辨率的情况下测试程序的显示是否正常</li>
<li>进行测试时还要注意状态栏是否显示正确；工具栏的图标执行操作是否有效，是否与菜单懒中图标显示一致；错误信息内容是否正确，无错别字，且明确等等</li>
</ol>
<h4 id="控件-测试方法"><a href="#控件-测试方法" class="headerlink" title="控件 测试方法"></a>控件 测试方法</h4><ol>
<li>窗体或控件的字体和大小要一致</li>
<li>注意全角，半角混合</li>
<li>无中英文混合</li>
</ol>
<h4 id="菜单-进行测试时要注意"><a href="#菜单-进行测试时要注意" class="headerlink" title="菜单 进行测试时要注意"></a>菜单 进行测试时要注意</h4><ol>
<li>选择菜单是否可以正常工作，并与实际执行内容一致</li>
<li>是否有错别字</li>
<li>快捷键是否重复</li>
<li>热键是否重复</li>
<li>快捷键与热键操作是否有效</li>
<li>是否存在中英文混合</li>
<li>菜单要与语境相关，如，不同权限的用户登陆一个应用程序，不同级别的用户可以看到不同级别的菜单并使用不同级别的功能</li>
<li>鼠标右键快捷菜单</li>
</ol>
<h4 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h4><ol>
<li>安装界面应有公司介绍或产品介绍，有公司的图标</li>
<li>主界面及大多数界面最好有公司图标</li>
<li>选择”帮助”-&gt;”关于”命令，应 看见相关版权和产品信息</li>
</ol>
<h2 id="七、实际中经常用到的几个用例"><a href="#七、实际中经常用到的几个用例" class="headerlink" title="七、实际中经常用到的几个用例"></a>七、实际中经常用到的几个用例</h2><h4 id="一、login"><a href="#一、login" class="headerlink" title="一、login"></a>一、login</h4><ol>
<li>链接地址是否正确</li>
<li>产生输入/输出错误时，系统是否进行检测并处理</li>
<li>密码输入框是否按掩码的方式显示</li>
</ol>
<h4 id="二、菜单"><a href="#二、菜单" class="headerlink" title="二、菜单"></a>二、菜单</h4><ol>
<li>各模块链接地址是否正确</li>
<li>鼠标无规则点击时是否会产生无法预料的结果</li>
</ol>
<h4 id="三、浏览"><a href="#三、浏览" class="headerlink" title="三、浏览"></a>三、浏览</h4><ol>
<li>浏览信息是否存在文字书写错误和语法错误</li>
<li>浏览信息是否和数据库中对应的字段及信息相一致</li>
<li>浏览页面中的链接按钮是否可以正确链接并显示</li>
<li>其他功能按钮按下后，数据是否按既定规约处理</li>
</ol>
<h4 id="四、增加，修改"><a href="#四、增加，修改" class="headerlink" title="四、增加，修改"></a>四、增加，修改</h4><ol>
<li>产生输入/输出错误时，系统是否进行检测并处理</li>
<li>列表框是否能够进行选择</li>
<li>单选组内是否有且只有一个单选钮可选</li>
<li>多选组内是否能够进行多数据项选择</li>
<li>多项列表框是否能够进行多数据项选择</li>
<li>控件是否存在默认输入值，若存在，默认值是否得到显示和提交</li>
<li>Cancel之类的按钮按下后，控件中的数据是否清空复原或按既定规约处理</li>
<li>取消之类的按钮按下后，数据是否得到提交或按既定规约处理</li>
<li>其他页面按钮按下后，数据是否按既定规约处理</li>
<li>异常信息表述是否正确</li>
</ol>
<h4 id="五、搜索"><a href="#五、搜索" class="headerlink" title="五、搜索"></a>五、搜索</h4><ol>
<li>输入信息中是否存在和代码中的字符产生冲突的字符，系统是否进行检测并处理</li>
<li>异常信息表述是否正确</li>
<li>查询的结果是否正确</li>
<li>列表框是否能够进行选择</li>
<li>单选组内是否有且只有一个单选钮可选</li>
<li>多选组内是否能够进行多数据项选择</li>
<li>多项列表框是否能够进行多数据项选择</li>
<li>提交之类的按钮按下后，数据是否得到提交或按既定规约处理</li>
</ol>
<h4 id="六、统计"><a href="#六、统计" class="headerlink" title="六、统计"></a>六、统计</h4><ol>
<li>产生的文件和数据表的计算结果是否正确</li>
<li>图表结果数据显示是否正确</li>
<li>浏览页面中的链接按钮是否可以正确链接并显示</li>
<li>其他功能按钮按下后，数据是否按既定规约处理</li>
<li>产生输入/输出错误时，系统是否进行检测并处理</li>
<li>列表框是否能够进行选择</li>
<li>单选组内是否有且只有一个单选钮可选</li>
<li>多选组内是否能够进行多数据项选择</li>
<li>多项列表框是否能够进行多数据项选择</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue_Test学习笔记</title>
    <url>/2024/01/08/vue_test/</url>
    <content><![CDATA[<h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><pre><code>├── node_modules 
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放静态资源
│   │   └── logo.png
│   │── component: 存放组件
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件
│   │── main.js: 入口文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
├── package-lock.json：包版本控制文件
</code></pre><h2 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue"></a>关于不同版本的Vue</h2><ol>
<li>vue.js与vue.runtime.xxx.js的区别：<ol>
<li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li>
<li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li>
</ol>
</li>
<li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li>
</ol>
<h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><ol>
<li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li>
<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li>
</ol>
<h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><ol>
<li>被用来给元素或子组件注册引用信息（id的替代者）</li>
<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：<ol>
<li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li>
<li>获取：<code>this.$refs.xxx</code></li>
</ol>
</li>
</ol>
<h2 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h2><ol>
<li><p>功能：让组件接收外部传过来的数据</p>
</li>
<li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p>
</li>
<li><p>接收数据：</p>
<ol>
<li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;]</code></p>
</li>
<li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p>
</li>
<li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123;</span><br><span class="line">	<span class="attr">name</span>:&#123;</span><br><span class="line">	<span class="attr">type</span>:<span class="title class_">String</span>, <span class="comment">//类型</span></span><br><span class="line">	<span class="attr">required</span>:<span class="literal">true</span>, <span class="comment">//必要性</span></span><br><span class="line">	<span class="attr">default</span>:<span class="string">&#x27;老王&#x27;</span> <span class="comment">//默认值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p>
</blockquote>
</li>
</ol>
<h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><ol>
<li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p>
</li>
<li><p>使用方式：</p>
<p>第一步定义混合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    data()&#123;....&#125;,</span><br><span class="line">    methods:&#123;....&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步使用混入：</p>
<p>​    全局混入：<code>Vue.mixin(xxx)</code><br>​    局部混入：<code>mixins:[&#39;xxx&#39;]</code></p>
</li>
</ol>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ol>
<li><p>功能：用于增强Vue</p>
</li>
<li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p>
</li>
<li><p>定义插件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 添加全局过滤器</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">filter</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 添加全局指令</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">directive</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 配置全局混入(合)</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;...&#125;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myProperty</span> = xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用插件：<code>Vue.use()</code></p>
</li>
</ol>
<h2 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h2><ol>
<li>作用：让样式在局部生效，防止冲突。</li>
<li>写法：<code>&lt;style scoped&gt;</code></li>
</ol>
<h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><ol>
<li><p>组件化编码流程：</p>
<p>​    (1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p>
<p>​    (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p>
<p>​            1).一个组件在用：放在组件自身即可。</p>
<p>​            2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p>
<p>​    (3).实现交互：从绑定事件开始。</p>
</li>
<li><p>props适用于：</p>
<p>​    (1).父组件 ==&gt; 子组件 通信</p>
<p>​    (2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数）</p>
</li>
<li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p>
</li>
<li><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p>
</li>
</ol>
<h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><ol>
<li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p>
</li>
<li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p>
</li>
<li><p>相关API：</p>
<ol>
<li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code><br>该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p>
</li>
<li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p>
<p>​        该方法接受一个键名作为参数，返回键名对应的值。</p>
</li>
<li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p>
<p>​        该方法接受一个键名作为参数，并把该键名从存储中删除。</p>
</li>
<li><p><code>xxxxxStorage.clear()</code></p>
<p>​        该方法会清空存储中的所有数据。</p>
</li>
</ol>
</li>
<li><p>备注：</p>
<ol>
<li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li>
<li>LocalStorage存储的内容，需要手动清除才会消失。</li>
<li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li>
<li><code>JSON.parse(null)</code>的结果依然是null。</li>
</ol>
</li>
</ol>
<h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol>
<li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===&gt; 父组件</strong></p>
</li>
<li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p>
</li>
<li><p>绑定自定义事件：</p>
<ol>
<li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p>
</li>
<li><p>第二种方式，在父组件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> ref=<span class="string">&quot;demo&quot;</span>/&gt;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">xxx</span>.$on(<span class="string">&#x27;atguigu&#x27;</span>,<span class="variable language_">this</span>.<span class="property">test</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p>
</li>
</ol>
</li>
<li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code></p>
</li>
<li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p>
</li>
<li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p>
</li>
<li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p>
</li>
</ol>
<h2 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>安装全局事件总线：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">	&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用事件总线：</p>
<ol>
<li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;xxxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p>
</li>
</ol>
</li>
<li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
</li>
</ol>
<h2 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>使用步骤：</p>
<ol>
<li><p>安装pubsub：<code>npm i pubsub-js</code></p>
</li>
<li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p>
</li>
<li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pid</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>) <span class="comment">//订阅消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p>
</li>
<li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p>
</li>
</ol>
</li>
</ol>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol>
<li>语法：<code>this.$nextTick(回调函数)</code></li>
<li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li>
<li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li>
</ol>
<h2 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h2><ol>
<li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li><p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%" /></p>
</li>
<li><p>写法：</p>
<ol>
<li><p>准备好样式：</p>
<ul>
<li>元素进入的样式：<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性,注意如果配置了appear属性的话就代表一开始挂载真实dom的时候就开启动画的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transition name=&quot;hello&quot; appear&gt;</span><br><span class="line">	&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
</li>
</ol>
</li>
</ol>
<h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​    在vue.config.js中添加如下配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">  <span class="attr">proxy</span>:<span class="string">&quot;http://localhost:5000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​    编写vue.config.js配置具体代理规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">	<span class="attr">devServer</span>: &#123;</span><br><span class="line">      <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api1&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/api2&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span></span><br><span class="line"><span class="comment">   changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol>
<li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong> 。</p>
</li>
<li><p>分类：默认插槽、具名插槽、作用域插槽</p>
</li>
<li><p>使用方式：</p>
<ol>
<li><p>默认插槽：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">           &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具名插槽：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">            &lt;template slot=&quot;center&quot;&gt;</span><br><span class="line">              &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">            &lt;template v-slot:footer&gt;</span><br><span class="line">               &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用域插槽：</p>
<ol>
<li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">		&lt;Category&gt;</span><br><span class="line">			&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class="line">				&lt;!-- 生成的是ul列表 --&gt;</span><br><span class="line">				&lt;ul&gt;</span><br><span class="line">					&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">				&lt;/ul&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">		&lt;Category&gt;</span><br><span class="line">			&lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class="line">				&lt;!-- 生成的是h4标题 --&gt;</span><br><span class="line">				&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">		</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            export default &#123;</span><br><span class="line">                name:&#x27;Category&#x27;,</span><br><span class="line">                props:[&#x27;title&#x27;],</span><br><span class="line">                //数据在子组件自身</span><br><span class="line">                data() &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>​        在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a>2.何时使用？</h3><p>​        多个组件需要共享数据时</p>
<h3 id="3-搭建vuex环境"><a href="#3-搭建vuex环境" class="headerlink" title="3.搭建vuex环境"></a>3.搭建vuex环境</h3><ol>
<li><p>创建文件：<code>src/store/index.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//应用Vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions对象——响应组件中用户的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;</span><br><span class="line"><span class="comment">//准备mutations对象——修改state中的数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;</span><br><span class="line"><span class="comment">//准备state对象——保存具体的数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	actions,</span><br><span class="line">	mutations,</span><br><span class="line">	state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	<span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	<span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">	store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><ol>
<li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//引用Vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="comment">//响应组件中加的动作</span></span><br><span class="line">	<span class="title function_">jia</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line">		<span class="comment">// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)</span></span><br><span class="line">		context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="comment">//执行加</span></span><br><span class="line">	<span class="title function_">JIA</span>(<span class="params">state,value</span>)&#123;</span><br><span class="line">		<span class="comment">// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)</span></span><br><span class="line">		state.<span class="property">sum</span> += value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">   <span class="attr">sum</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	actions,</span><br><span class="line">	mutations,</span><br><span class="line">	state,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>
</li>
<li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>
<blockquote>
<p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3 id="5-getters的使用"><a href="#5-getters的使用" class="headerlink" title="5.getters的使用"></a>5.getters的使用</h3><ol>
<li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p>
</li>
<li><p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">    <span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    ......</span><br><span class="line">    getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3 id="6-四个map方法的使用"><a href="#6-四个map方法的使用" class="headerlink" title="6.四个map方法的使用"></a>6.四个map方法的使用</h3><ol>
<li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（对象写法）</span></span><br><span class="line">     ...<span class="title function_">mapState</span>(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>,<span class="attr">subject</span>:<span class="string">&#x27;subject&#x27;</span>&#125;),</span><br><span class="line">         </span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：increment、decrement（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
</blockquote>
<h3 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h3><ol>
<li><p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li><p>修改<code>store.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    countAbout,</span><br><span class="line">    personAbout</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中读取state数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personAbout</span>.<span class="property">list</span></span><br><span class="line"><span class="comment">//方式二：借助mapState读取：</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中读取getters数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;personAbout/firstPersonName&#x27;</span>]</span><br><span class="line"><span class="comment">//方式二：借助mapGetters读取：</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中调用dispatch</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;personAbout/addPersonWang&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapActions：</span></span><br><span class="line">...<span class="title function_">mapActions</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中调用commit</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接commit</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapMutations：</span></span><br><span class="line">...<span class="title function_">mapMutations</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key是路径，value是组件。</li>
</ol>
<h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><ol>
<li><p>安装vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li><p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li><p>编写router配置项:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入Luyou 组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">	<span class="attr">routes</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现切换（active-class可配置高亮样式）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定展示位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h3></li>
<li><p>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</p>
</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h3 id="3-多级路由（多级路由）"><a href="#3-多级路由（多级路由）" class="headerlink" title="3.多级路由（多级路由）"></a>3.多级路由（多级路由）</h3><ol>
<li><p>配置路由规则，使用children配置项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>:<span class="title class_">About</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">		<span class="attr">children</span>:[ <span class="comment">//通过children配置子级路由</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>, <span class="comment">//此处一定不要写：/news</span></span><br><span class="line">				<span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,<span class="comment">//此处一定不要写：/message</span></span><br><span class="line">				<span class="attr">component</span>:<span class="title class_">Message</span></span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>跳转（要写完整路径）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h3><ol>
<li><p>传递参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line">				</span><br><span class="line">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to=&quot;&#123;</span><br><span class="line">		path:&#x27;/home/message/detail&#x27;,</span><br><span class="line">		query:&#123;</span><br><span class="line">		   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$route.<span class="property">query</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">query</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h3><ol>
<li><p>作用：可以简化路由的跳转。</p>
</li>
<li><p>如何使用</p>
<ol>
<li><p>给路由命名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;/demo&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Demo</span>,</span><br><span class="line">	<span class="attr">children</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Test</span>,</span><br><span class="line">			<span class="attr">children</span>:[</span><br><span class="line">				&#123;</span><br><span class="line">                      <span class="attr">name</span>:<span class="string">&#x27;hello&#x27;</span> <span class="comment">//给路由命名</span></span><br><span class="line">					<span class="attr">path</span>:<span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line">					<span class="attr">component</span>:<span class="title class_">Hello</span>,</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>简化跳转：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to=&quot;&#123;</span><br><span class="line">		name:&#x27;hello&#x27;,</span><br><span class="line">		query:&#123;</span><br><span class="line">		   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="6-路由的params参数"><a href="#6-路由的params参数" class="headerlink" title="6.路由的params参数"></a>6.路由的params参数</h3><ol>
<li><p>配置路由，声明接收params参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">	<span class="attr">children</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line">			<span class="attr">children</span>:[</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">					<span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title&#x27;</span>, <span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line">					<span class="attr">component</span>:<span class="title class_">Detail</span></span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传递参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line">				</span><br><span class="line">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to=&quot;&#123;</span><br><span class="line">		name:&#x27;xiangqing&#x27;,</span><br><span class="line">		params:&#123;</span><br><span class="line">		   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p>
</blockquote>
</li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$route.<span class="property">params</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">params</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="7-路由的props配置"><a href="#7-路由的props配置" class="headerlink" title="7.路由的props配置"></a>7.路由的props配置</h3><p>​    作用：让路由组件更方便的收到参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;detail/:id&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line">	<span class="comment">// props:&#123;a:900&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line">	<span class="comment">// props:true</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class="line">	<span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">id</span>:route.<span class="property">query</span>.<span class="property">id</span>,</span><br><span class="line">			<span class="attr">title</span>:route.<span class="property">query</span>.<span class="property">title</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-lt-router-link-gt-的replace属性"><a href="#8-lt-router-link-gt-的replace属性" class="headerlink" title="8.&lt;router-link&gt;的replace属性"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h3><ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h3 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h3><ol>
<li><p>作用：不借助<code>&lt;router-link&gt;</code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">		<span class="attr">params</span>:&#123;</span><br><span class="line">			<span class="attr">id</span>:xxx,</span><br><span class="line">			<span class="attr">title</span>:xxx</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">		<span class="attr">params</span>:&#123;</span><br><span class="line">			<span class="attr">id</span>:xxx,</span><br><span class="line">			<span class="attr">title</span>:xxx</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>() <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>() <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>() <span class="comment">//可前进也可后退 参数是number类型(正数为前进的步数,负数为后退的部署)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h3><ol>
<li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;News&quot;&gt; </span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h3><ol>
<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>
<li>具体名字：<ol>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发。</li>
</ol>
</li>
</ol>
<h3 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h3><ol>
<li><p>作用：对路由进行权限控制</p>
</li>
<li><p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li><p>全局守卫:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123; <span class="comment">//权限控制的具体规则</span></span><br><span class="line">			<span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">			<span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;afterEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">title</span>)&#123; </span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">title</span> = to.<span class="property">meta</span>.<span class="property">title</span> <span class="comment">//修改网页的title</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;vue_test&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>独享守卫:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEnter&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line">			<span class="title function_">next</span>()</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">			<span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="title function_">next</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件内守卫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入守卫：通过路由规则，进入该组件时被调用</span></span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//离开守卫：通过路由规则，离开该组件时被调用</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h3><ol>
<li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li>
<li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li>
<li>hash模式：<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li>history模式：<ol>
<li>地址干净，美观 。</li>
<li>兼容性和hash模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
